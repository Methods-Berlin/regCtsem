[{"path":"https://jhorzek.github.io/regCtsem/articles/MatrixExponential.html","id":"matrix-exponential-in-ctsem","dir":"Articles","previous_headings":"","what":"Matrix exponential in c++tsem","title":"MatrixExponential","text":"c++tsem relies heavily RcppArmadillo library. can sometimes lead results deviate ctsem. Especially matrix exponential can prone numerical precision problems. Example: Note huge differences matrix exponential using RcppArmadillo OpenMx.","code":"library(regCtsem) #> Loading required package: ctsemOMX #> Loading required package: ctsem #> Loading required package: Rcpp #> ctsem also changes in time, for manual run ctDocs(), for blog see https://cdriver.netlify.app/, for citation info run citation('ctsem'), for original OpenMx functionality install.packages('ctsemOMX'), and for discussion https://github.com/cdriveraus/ctsem/discussions #> Warning in doTryCatch(return(expr), name, parentenv, handler): The following #> important packages for ctsem are out of date: rstan, ctsem #> Loading required package: OpenMx #>  #> Attaching package: 'ctsemOMX' #> The following objects are masked from 'package:ctsem': #>  #>     ctFit, ctIndplot set.seed(53455)  randMat <- matrix(stats::rnorm(n = 64,                          mean = 0,                          sd = 10),                    nrow = 8, ncol = 8)  regCtsem:::armaExpmat(randMat) - OpenMx::expm(randMat) #>            [,1]       [,2]       [,3]      [,4]       [,5]       [,6] #> [1,]  -768.5128  232.49915  -961.5552 -342.9163  125.22721  1258.8476 #> [2,] -1209.0286  365.76894 -1512.7241 -539.4778  197.00813  1980.4258 #> [3,]   408.5591 -123.60188   511.1849  182.3022  -66.57366  -669.2322 #> [4,]   378.3700 -114.46876   473.4127  168.8316  -61.65444  -619.7817 #> [5,]  1343.3712 -406.41174  1680.8121  599.4224 -218.89891 -2200.4831 #> [6,]  2867.5182 -867.51385  3587.8090 1279.5085 -467.25479 -4697.0826 #> [7,]   287.3833  -86.94242   359.5710  128.2326  -46.82837  -470.7426 #> [8,]  1806.3732 -546.48431  2260.1154  806.0175 -294.34392 -2958.8947 #>            [,7]       [,8] #> [1,] -252.35180  1060.8234 #> [2,] -397.00122  1668.8932 #> [3,]  134.15601  -563.9581 #> [4,]  124.24302  -522.2864 #> [5,]  441.11446 -1854.3340 #> [6,]  941.58920 -3958.2036 #> [7,]   94.36626  -396.6920 #> [8,]  593.14757 -2493.4430"},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"ctsem","dir":"Articles","previous_headings":"","what":"c++tsem","title":"cpptsem","text":"regCtsem try internally translate ctsem object passed main function (regCtsem:::regCtsem) C++ object. functions C++ object implemented following naming scheme c++tsem. sole purpose translation speeding computation -2 log-Likelihood approximation gradients continuous time structural equation models. implementation closely follows ctsemOMX (Driver et al., 2017). Known limitations Time dependent predictors yet supported c++tsem.","code":""},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"demonstration-of-main-functions","dir":"Articles","previous_headings":"c++tsem","what":"Demonstration of main functions","title":"cpptsem","text":"demonstrate application c++tsem, example ctsem used. general workflow c++tsem using reticular action model (RAM) : translate ctsem c++tsem computeRAM() computes , S, M matrices well expected means covariances fitRAM() computes -2log-likelihood approxRAMGradients((1.1 * 10^(-16))^(1/3)) computes gradients general workflow c++tsem using Kalman filter : translate ctsem c++tsem computeAndFitKalman(0) computes predicted updated latent scores well -2log-Likelihood. number indicates person fit calculated: 0 = full sample, 1,…, N individual 1, …, N. latent scores can extracted $latentScores approxKalmanGradients((1.1 * 10^(-16))^(1/3)) computes gradients explained detail using RAM model. Otherwise, details can found :","code":"library(ctsemOMX) library(regCtsem)  # set up model with ctsem data(\"AnomAuth\") AnomAuthmodel <- ctModel(LAMBDA = matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2),                          Tpoints = 5, n.latent = 2, n.manifest = 2,                           MANIFESTVAR=diag(0, 2), TRAITVAR = \"auto\") # the optimizer will not used here because the gradients would otherwise  # be very close to zero and the similarity between the OpenMx based  # gradients and the cpptsem based gradients would be harder to see: AnomAuthfit <- ctFit(AnomAuth, AnomAuthmodel, useOptimizer = F) ?cpptsemFromCtsem"},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"translate-ctsem-object-to-ctsem","dir":"Articles","previous_headings":"c++tsem > Demonstration of main functions","what":"Translate ctsem object to c++tsem","title":"cpptsem","text":"function cpptsemFromCtsem translates fitted ctsem object (e.g., AnomAuthfit example ) new object class Rcpp_cpptsemmodel:","code":"cpptsemmodel <- regCtsem:::cpptsemFromCtsem(AnomAuthfit, wideData = AnomAuth) #> Translating model to C++. Found the following elements: T0MEANS, T0VARbase, DRIFT, DIFFUSIONbase, TRAITVARbase, T0TRAITEFFECT, CINT, MANIFESTMEANS, LAMBDA, MANIFESTVARbase."},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"compute-the-ram-matrices","dir":"Articles","previous_headings":"c++tsem > Demonstration of main functions","what":"Compute the RAM matrices","title":"cpptsem","text":"cpptsem object created, RAM matrices discrete time parameters can obtained using computeRAM() function. compute matrix (directed effects), S matrix (residual covariances), M vector (means) well expected means expected covariances. elements can accessed $ operator:","code":"cpptsemmodel$computeRAM() cpptsemmodel$A cpptsemmodel$S cpptsemmodel$M cpptsemmodel$F cpptsemmodel$expectedMeans cpptsemmodel$expectedCovariance"},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"compute-the--2-log-likelihood","dir":"Articles","previous_headings":"c++tsem > Demonstration of main functions","what":"Compute the -2 log likelihood","title":"cpptsem","text":"function fitRAM() computes -2 log likelihood based data expected means covariances. can now compare results ctsem:","code":"cpptsemmodel$fitRAM() cpptsemmodel$m2LL #> [1] 86098.36 AnomAuthfit$mxobj$fitfunction$result[[1]] #> [1] 86098.36"},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"finite-difference-derivative-approximation-of-the-gradients","dir":"Articles","previous_headings":"c++tsem > Demonstration of main functions","what":"Finite difference derivative approximation of the gradients","title":"cpptsem","text":"derivative likelihood respect parameters computed based finite differencing. procedure follows: parameter (1.1) take minimal step forward (parameter + epsilon), (1.2) compute -2 log likelihood, (2.1) take minimal step backward (parameter - epsilon), (2.2) compute -2 log likelihood, (3) compute difference likelihoods divide 2*epsilon. -called central differencing performed approxRAMGradients function: , results can compared values OpenMx:","code":"cpptsemGradients <- cpptsemmodel$approxRAMGradients((1.1 * 10^(-16))^(1/3))  # epsilon = (1.1 * 10^(-16))^(1/3) sets the precision of the numerical approximation.  # Smaller numbers result in higher precision, but might also result in  # errors due to the numerical precision of the computer. The value used here is recommended # in Nocedal, J., & Wright, S. J. (2006). Numerical optimization (2nd ed). Springer. See p. 197. gradientModel <- OpenMx::mxRun(OpenMx::mxModel(AnomAuthfit$mxobj,                                                OpenMx::mxComputeSequence(steps=list(                                                  OpenMx::mxComputeNumericDeriv(                                                    checkGradient = FALSE,                                                    hessian = FALSE))                                                ))) ctsemGradients <- gradientModel$compute$steps[[1]]$output[[\"gradient\"]][,\"central\"] names(ctsemGradients) <- rownames(gradientModel$compute$steps[[1]]$output[[\"gradient\"]]) cpptsemGradients[names(ctsemGradients)] #>           T0m_eta1           T0m_eta2         drift_eta1    drift_eta2_eta1  #>         -159.38084         -194.83046         3741.36498         -590.07744  #>    drift_eta1_eta2         drift_eta2          diff_eta1     diff_eta2_eta1  #>         -572.21704         3913.61909         6878.87533          -26.37738  #>          diff_eta2         T0var_eta1    T0var_eta2_eta1         T0var_eta2  #>         7975.03673         4506.75990          -59.45377         4293.07316  #>              mm_Y1              mm_Y2      traitvar_eta1 traitvar_eta2_eta1  #>         -213.00137         -314.51901          521.43165          -27.37396  #>      traitvar_eta2  #>          458.57700 ctsemGradients #>           T0m_eta1           T0m_eta2         drift_eta1    drift_eta2_eta1  #>         -159.38083         -194.83046         3741.36496         -590.07747  #>    drift_eta1_eta2         drift_eta2          diff_eta1     diff_eta2_eta1  #>         -572.21707         3913.61907         6878.87533          -26.37738  #>          diff_eta2         T0var_eta1    T0var_eta2_eta1         T0var_eta2  #>         7975.03673         4506.75989          -59.45377         4293.07316  #>              mm_Y1              mm_Y2      traitvar_eta1 traitvar_eta2_eta1  #>         -213.00136         -314.51901          521.43164          -27.37396  #>      traitvar_eta2  #>          458.57700"},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"changing-parameter-values","dir":"Articles","previous_headings":"c++tsem > Demonstration of main functions","what":"Changing parameter values","title":"cpptsem","text":"Finally, setParameterValues() can used change parameter values cpptsem model.","code":"# to have a second set of parameter values the ctsem model is fitted again. # However, this time the optimizer is used: AnomAuthfit2 <- ctFit(AnomAuth, AnomAuthmodel, useOptimizer = T)  # extract parameters: newParameters <- OpenMx::omxGetParameters(AnomAuthfit2$mxobj)  cpptsemmodel$setParameterValues(newParameters, names(newParameters)) cpptsemmodel$getParameterValues()[names(newParameters)]"},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"application-example-1-time-differences-in-gradient-computation","dir":"Articles","previous_headings":"c++tsem","what":"Application Example 1: Time differences in gradient computation","title":"cpptsem","text":"main motivation c++tsem faster way compute gradients ctsem. necessary specific situations, however found working mxObject ctsem computing just gradients can quite slow. reason might model set every time computed gradients. possible faster way compute gradients ctsem / OpenMx, couldn’t find . following short demonstration time differences approach ctsem / OpenMx computation c++tsem demonstrated: 100 repetitive computations gradients, ctsem / OpenMx took 20.7287621498108 seconds, c++tsem took 0.190791845321655 seconds. Importantly mean c++tsem always faster! faster specific application. differences also tend become smaller missings data set. However c++tsem still tends outperform ctsem / OpenMx approach factor around 10.","code":"library(ctsemOMX) library(regCtsem)  set.seed(64356)  ## define the population model:  # set the drift matrix ct_drift <- matrix(c(-.3,.2,0,-.5), ncol = 2)  generatingModel<-ctsem::ctModel(Tpoints=10,n.latent=2,n.TDpred=0,n.TIpred=0,n.manifest=2,                                 MANIFESTVAR=diag(0,2),                                 LAMBDA=diag(1,2),                                 DRIFT=ct_drift,                                 DIFFUSION=matrix(c(.5,0,0,.5),2),                                 CINT=matrix(c(0,0),nrow=2),                                 T0MEANS=matrix(0,ncol=1,nrow=2),                                 T0VAR=diag(1,2), type = \"omx\")  # simulate a training data set dat <- ctsem::ctGenerate(generatingModel,n.subjects = 100, wide = TRUE)  ## Build the analysis model.  myModel <- ctsem::ctModel(Tpoints=10,n.latent=2,n.TDpred=0,n.TIpred=0,n.manifest=2,                           LAMBDA=diag(1,2),                           MANIFESTVAR=diag(0,2),                           CINT=matrix(c(0,0),nrow=2),                           DIFFUSION=matrix(c('eta1_eta1',0,0,'eta2_eta2'),2),                           T0MEANS=matrix(0,ncol=1,nrow=2),                           T0VAR=\"auto\", type = \"omx\")  # fit the model using ctsemOMX: fit_myModel <- ctsemOMX::ctFit(dat, myModel)  repetitions <- 100  # set up the gradient model for ctsem / OpenMx  gradientModel <- OpenMx::mxModel(fit_myModel$mxobj,                                  OpenMx::mxComputeSequence(steps=list(                                    OpenMx::mxComputeNumericDeriv(                                      checkGradient = FALSE,                                      hessian = FALSE))                                  ))  # set up the model for cpptsem cpptsemGradientDemonstation <- regCtsem:::cpptsemFromCtsem(fit_myModel, wideData = dat) cpptsemGradientDemonstation$computeRAM() cpptsemGradientDemonstation$fitRAM()  OpenMxStart <- Sys.time() for(i in 1:repetitions){   gradientModel <- mxRun(gradientModel, silent = TRUE) } OpenMxEnd <- Sys.time()  CpptsemStart <- Sys.time() for(i in 1:repetitions){   cpptsemGradients <- cpptsemGradientDemonstation$approxRAMGradients((1.1 * 10^(-16))^(1/3))  } CpptsemEnd <- Sys.time()"},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"application-example-2-general-purpose-optimizer-with-ram","dir":"Articles","previous_headings":"c++tsem","what":"Application Example 2: General purpose optimizer with RAM","title":"cpptsem","text":"c++tsem can used general purpose optimizers solnp optim. following use optim demonstrated: Comparison parameter estimates: ctsem c++tsem Comparison fit: ctsem c++tsem quick note optimization: SEMs quite difficult optimize objective function convex. (limited) experience c++tsem optim, observed sometimes optim approach outperforms ctsem sometimes ’s way around. seems come whichever two optimizers ends bad spot due local minima.","code":"library(ctsemOMX) library(regCtsem)  # set up model with ctsem data(\"AnomAuth\") AAmodel <- ctModel(LAMBDA = matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2),                    Tpoints = 5, n.latent = 2, n.manifest = 2,                     MANIFESTVAR=diag(0, 2), TRAITVAR = \"auto\") # generate ctsem object, but don't optimize: AANotOptimized <- ctFit(AnomAuth, AAmodel, useOptimizer = F)  # for later comparison: optimized ctsem object: AACtsemFit <- ctFit(AnomAuth, AAmodel, useOptimizer = T)   # translate to cpptsem: AACpptsem <- regCtsem:::cpptsemFromCtsem(AANotOptimized, wideData = AnomAuth)  startingValues <- omxGetParameters(AANotOptimized$mxobj)  m2LLCpptsem <- function(parameters, cpptsemmodel){   cpptsemmodel$setParameterValues(parameters, names(parameters))   # catching all errors from cpptsemmodel    # when parameter values are impossible   invisible(utils::capture.output(RAM <- try(cpptsemmodel$computeRAM(),                                        silent = TRUE),                             type = \"message\"))   invisible(utils::capture.output(FIT <- try(cpptsemmodel$fitRAM(),                                       silent = TRUE),                             type = \"message\"))      if(class(RAM) == \"try-error\" | class(FIT) == \"try-error\"){     return(NA)   }   return(cpptsemmodel$m2LL) }  gradCpptsem <- function(parameters, cpptsemmodel){   invisible(utils::capture.output(grad <- try(cpptsemmodel$approxRAMGradients((1.1 * 10^(-16))^(1/3)),                                         silent = TRUE),                             type = \"message\"))   if(class(grad) == \"try-error\"){     return(NA)   }   return(grad[names(parameters)]) }  # compute  AACpptsemFit <- stats::optim(par = startingValues,                        fn = m2LLCpptsem,                        gr = gradCpptsem,                         AACpptsem,                        method = \"BFGS\") omxGetParameters(AACtsemFit$mxobj) #>           T0m_eta1           T0m_eta2         drift_eta1    drift_eta2_eta1  #>       -0.187016954       -0.028472448       -2.480228865        0.045944318  #>    drift_eta1_eta2         drift_eta2          diff_eta1     diff_eta2_eta1  #>        0.272356174       -0.224282818        0.071472736        0.007714258  #>          diff_eta2         T0var_eta1    T0var_eta2_eta1         T0var_eta2  #>       -0.880949144       -0.669434040        0.049743273       -0.859045048  #>              mm_Y1              mm_Y2      traitvar_eta1 traitvar_eta2_eta1  #>        2.690368114        2.871194481       -0.468550052        0.355051374  #>      traitvar_eta2  #>       -0.947172540 AACpptsemFit$par #>           T0m_eta1           T0m_eta2         drift_eta1    drift_eta2_eta1  #>       -0.187019747       -0.028470912       -2.480133756        0.045822393  #>    drift_eta1_eta2         drift_eta2          diff_eta1     diff_eta2_eta1  #>        0.272189556       -0.224275450        0.071455746        0.007747149  #>          diff_eta2         T0var_eta1    T0var_eta2_eta1         T0var_eta2  #>       -0.880944640       -0.669443190        0.049734737       -0.859053977  #>              mm_Y1              mm_Y2      traitvar_eta1 traitvar_eta2_eta1  #>        2.690371260        2.871192033       -0.468545422        0.355059365  #>      traitvar_eta2  #>       -0.947134280 # ctsem: AACtsemFit$mxobj$fitfunction$result[[1]] #> [1] 22898.53 AACpptsemFit$value #> [1] 22898.53"},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"application-example-3-general-purpose-optimizer-with-kalman-filter","dir":"Articles","previous_headings":"c++tsem","what":"Application Example 3: General purpose optimizer with Kalman filter","title":"cpptsem","text":"Similar example 2, c++tsem can used general purpose optimizers solnp optim using Kalman filter. following use solnp demonstrated: Comparison parameter estimates: ctsem c++tsem Comparison fit: ctsem c++tsem comparing speed optimizing model using OpenMx c++tsem using solnp, Kalman filter implementation c++tsem appears slightly faster:","code":"library(regCtsem) library(ctsemOMX) set.seed(175446) ## define the population model:  # set the drift matrix. Note that drift eta_1_eta2 is set to equal 0 in the population. ct_drift <- matrix(c(-.3,.2,0,-.5), ncol = 2)  generatingModel<-ctsem::ctModel(Tpoints=20,n.latent=2,n.TDpred=0,n.TIpred=0,n.manifest=2,                                 MANIFESTVAR=diag(0,2),                                 LAMBDA=diag(1,2),                                 DRIFT=ct_drift,                                 DIFFUSION=matrix(c(.5,0,0,.5),2),                                 CINT=matrix(0,nrow = 2, ncol = 1),                                 T0MEANS=matrix(0,ncol=1,nrow=2),                                 T0VAR=diag(1,2), type = \"omx\")  # simulate a training data and testing data set traindata <- ctsem::ctGenerate(generatingModel,n.subjects = 50, wide = TRUE)  ## Build the analysis model. Note that drift eta1_eta2 is freely estimated # although it is 0 in the population. kalmanModel <- ctsem::ctModel(Tpoints=20,n.latent=2,n.TDpred=0,n.TIpred=0,n.manifest=2,                               LAMBDA=diag(1,2),                               MANIFESTVAR=diag(0,2),                               CINT=matrix(0,nrow = 2, ncol = 1),                               DIFFUSION=matrix(c('eta1_eta1',0,0,'eta2_eta2'),2),                               T0MEANS=matrix(0,ncol=1,nrow=2),                               T0VAR=\"auto\", type = \"omx\") kalmanModelNotOptimized <- ctFit(kalmanModel, dat = traindata,                                   objective = \"Kalman\", useOptimizer = F) # fitted model for later comparison: kalmanModelOptimized <- ctFit(kalmanModel, dat = traindata,                                objective = \"Kalman\", useOptimizer = T) ## with cpptsem kalmanCpptsemmodel <- regCtsem:::cpptsemFromCtsem(ctsemModel = kalmanModelNotOptimized,                                                  wideData = traindata)  startingValues <- omxGetParameters(kalmanModelNotOptimized$mxobj)  m2LLCpptsem <- function(parameters, cpptsemmodel){   cpptsemmodel$setParameterValues(parameters, names(parameters))   # catching all errors from cpptsemmodel    # when parameter values are impossible   invisible(utils::capture.output(KALMAN <- try(cpptsemmodel$computeAndFitKalman(0),                                           silent = TRUE),                             type = \"message\"))      if(class(KALMAN) == \"try-error\" | is.na(cpptsemmodel$m2LL)){     return(99999999)   }   return(cpptsemmodel$m2LL) }  # compute  kalmanCpptsemFit <- Rsolnp::solnp(pars = startingValues,                                    fun = m2LLCpptsem,                                    eqfun = NULL, eqB = NULL, ineqfun = NULL, ineqLB = NULL,                                    ineqUB = NULL, LB = NULL, UB = NULL, control = list(trace = 0),                                   kalmanCpptsemmodel) omxGetParameters(kalmanModelOptimized$mxobj) #>      drift_eta1 drift_eta2_eta1 drift_eta1_eta2      drift_eta2       eta1_eta1  #>     -0.28179207      0.18633329      0.01358409     -0.47165193     -0.65454891  #>       eta2_eta2      T0var_eta1 T0var_eta2_eta1      T0var_eta2           mm_Y1  #>     -0.70071095     -0.15530510      0.07399650     -0.09844141      0.06861351  #>           mm_Y2  #>      0.04118951 kalmanCpptsemFit$pars #>      drift_eta1 drift_eta2_eta1 drift_eta1_eta2      drift_eta2       eta1_eta1  #>     -0.28179127      0.18633833      0.01358279     -0.47165845     -0.65454790  #>       eta2_eta2      T0var_eta1 T0var_eta2_eta1      T0var_eta2           mm_Y1  #>     -0.70070624     -0.15534835      0.07395015     -0.09844003      0.06861400  #>           mm_Y2  #>      0.04118876 # ctsem: kalmanModelOptimized$mxobj$fitfunction$result[[1]] #> [1] 2410.442 kalmanCpptsemFit$values #> [1] 12108.198  2410.442  2410.442 system.time(replicate(10, Rsolnp::solnp(pars = startingValues,                                          fun = m2LLCpptsem,                                          eqfun = NULL, eqB = NULL,                                          ineqfun = NULL, ineqLB = NULL,                                          ineqUB = NULL, LB = NULL,                                          UB = NULL, control = list(trace = 0),                                         kalmanCpptsemmodel))) #>    user  system elapsed  #>  14.896  23.006   6.324 system.time(replicate(10, mxRun(kalmanModelNotOptimized$mxobj,                                  silent = TRUE))) #>    user  system elapsed  #>  47.778   2.401   9.472"},{"path":[]},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"translation-from-ctsem","dir":"Articles","previous_headings":"c++tsem > Advanced: How it works","what":"Translation from ctsem","title":"cpptsem","text":"cpptsemFromCtsem function automatically translates fitted ctsem model c++tsem. following, steps discussed detail.","code":""},{"path":[]},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"ram","dir":"Articles","previous_headings":"","what":"cpptsem","title":"cpptsem","text":"First, constructDataset function separate observations discrete time intervals. also identify unique missingness patterns. next step, prepareRAMData group individuals identical missingness patterns subsamples. subsamples later used fitRAM() speed likelihood computation.","code":"dataInformation <- regCtsem:::constructDataset(wideData = AnomAuthfit$mxobj$data$observed) dataForRAM <- regCtsem:::prepareRAMData(dataset = dataInformation$dataset,                                        individualMissingPatternID = dataInformation$individualMissingPatternID,                                        uniqueMissingPatterns = dataInformation$uniqueMissingPatterns)"},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"kalman","dir":"Articles","previous_headings":"","what":"cpptsem","title":"cpptsem","text":"Kalman filter, functions constructDataset prepareKalmanData. contrast prepareRAMData, prepareKalmanData identify unique missingness patterns, speed computation.","code":"dataInformation <- regCtsem:::constructDataset(wideData = wideData) dataForKalman <- regCtsem:::prepareKalmanData(dataset = dataInformation$dataset,                                              nlatent = nlatent, nmanifest = nmanifest,                                              dtIndicators = dataInformation$dtIndicators,                                              Tpoints = Tpoints)"},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"limitations","dir":"Articles","previous_headings":"","what":"cpptsem","title":"cpptsem","text":"ctsem datasets possible different time intervals within single column: moment, c++tsem supports data format using Kalman filter. RAM models time intervals data set individuals. However, individually varying time intervals observations allwed means missingness. instance, AnomAuth data set individual 6 missings observations account individually differing time intervals:","code":"data(\"Oscillating\") head(Oscillating[,grepl(\"dT\", colnames(Oscillating))]) #>    dT1  dT2  dT3  dT4  dT5  dT6  dT7  dT8  dT9 dT10 #> 1 0.55 0.32 0.36 0.34 0.40 0.32 0.30 0.29 0.34 0.32 #> 2 0.56 0.42 0.34 0.38 0.43 0.47 0.44 0.52 0.42 0.38 #> 3 0.46 0.50 0.37 0.34 0.46 0.34 0.50 0.36 0.34 0.46 #> 4 0.50 0.35 0.29 0.42 0.44 0.57 0.43 0.38 0.57 0.42 #> 5 0.37 0.40 0.33 0.39 0.36 0.35 0.20 0.44 0.50 0.45 #> 6 0.46 0.35 0.35 0.43 0.44 0.49 0.44 0.37 0.51 0.36 head(AnomAuth) #>   Y1_T0 Y2_T0 Y1_T1 Y2_T1 Y1_T2 Y2_T2 Y1_T3 Y2_T3 Y1_T4 Y2_T4 dT1 dT2 dT3 dT4 #> 1  2.67  3.50  3.33   3.5    NA    NA    NA    NA    NA    NA   1   1   2   2 #> 2  3.33  3.25    NA    NA    NA    NA    NA    NA    NA    NA   1   1   2   2 #> 3  3.33  2.75  3.33   3.0  3.33   2.5  2.33     3  2.33     3   1   1   2   2 #> 4  3.33  3.25    NA    NA    NA    NA    NA    NA    NA    NA   1   1   2   2 #> 5  4.00  4.00    NA    NA    NA    NA    NA    NA    NA    NA   1   1   2   2 #> 6  3.67  4.00    NA    NA    NA    NA  4.00     4  4.00     4   1   1   2   2"},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"step-2-extract-continuous-time-matrices","dir":"Articles","previous_headings":"c++tsem > Advanced: How it works","what":"Step 2: Extract continuous time matrices","title":"cpptsem","text":"function extractCtsemMatrices searches typical matrices ctsem. (see ctsem details): latent part: T0MEANS T0VARbase DRIFT DIFFUSIONbase TRAITVARbase T0TRAITEFFECT CINT manifest part: MANIFESTMEANS LAMBDA MANIFESTVARbase Note time dependent predictors currently supported. matrices, c++tsem saves values parameter names. example:","code":"ctMatrices <- regCtsem:::extractCtsemMatrices(AnomAuthfit$mxobj,                                               AnomAuthfit$ctmodelobj$n.latent,                                              AnomAuthfit$ctmodelobj$n.manifest) #> Translating model to C++. Found the following elements: T0MEANS, T0VARbase, DRIFT, DIFFUSIONbase, TRAITVARbase, T0TRAITEFFECT, CINT, MANIFESTMEANS, LAMBDA, MANIFESTVARbase. ctMatrices$DRIFT #> $values #>       [,1]  [,2] #> [1,] -0.45 -0.05 #> [2,] -0.05 -0.45 #>  #> $names #>      [,1]              [,2]              #> [1,] \"drift_eta1\"      \"drift_eta1_eta2\" #> [2,] \"drift_eta2_eta1\" \"drift_eta2\""},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"step-3-extract-parameter-table","dir":"Articles","previous_headings":"c++tsem > Advanced: How it works","what":"Step 3: Extract parameter table","title":"cpptsem","text":"important part c++tsem option change parameter values. end, c++tsem uses parameter table can extracted mxobj ctsem: Note matrix column table tells us ctMatrices parameter value belongs including specification row column matrix. Similar OpenMx, c++tsem uses information change parameter values. demonstrated , can done setParameterValues() function.","code":"OpenMx::omxLocateParameters(AnomAuthfit$mxobj) #>                 label model        matrix row col     value lbound ubound #> 1           diff_eta1 ctsem DIFFUSIONbase   1   1  2.302584     NA     NA #> 2           diff_eta2 ctsem DIFFUSIONbase   2   2  2.302584     NA     NA #> 3      diff_eta2_eta1 ctsem DIFFUSIONbase   2   1  0.100000     NA     NA #> 4          drift_eta1 ctsem         DRIFT   1   1 -0.450000     NA     NA #> 5     drift_eta1_eta2 ctsem         DRIFT   1   2 -0.050000     NA     NA #> 6          drift_eta2 ctsem         DRIFT   2   2 -0.450000     NA     NA #> 7     drift_eta2_eta1 ctsem         DRIFT   2   1 -0.050000     NA     NA #> 8               mm_Y1 ctsem MANIFESTMEANS   1   1  0.718000     NA     NA #> 9               mm_Y2 ctsem MANIFESTMEANS   2   1 -1.866000     NA     NA #> 10           T0m_eta1 ctsem       T0MEANS   1   1 -1.548000     NA     NA #> 11           T0m_eta2 ctsem       T0MEANS   2   1  0.568000     NA     NA #> 12         T0var_eta1 ctsem     T0VARbase   1   1  2.302585     NA     NA #> 13         T0var_eta2 ctsem     T0VARbase   2   2  2.302585     NA     NA #> 14    T0var_eta2_eta1 ctsem     T0VARbase   2   1  0.100000     NA     NA #> 15      traitvar_eta1 ctsem  TRAITVARbase   1   1  1.098612     NA     NA #> 16      traitvar_eta2 ctsem  TRAITVARbase   2   2  1.098612     NA     NA #> 17 traitvar_eta2_eta1 ctsem  TRAITVARbase   2   1  0.100000     NA     NA"},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"limiation","dir":"Articles","previous_headings":"c++tsem > Advanced: How it works > Step 3: Extract parameter table","what":"Limiation","title":"cpptsem","text":"Lower upper bounds parameters currently supported!","code":""},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"step-4-1-prepare-ram-matrices","dir":"Articles","previous_headings":"c++tsem > Advanced: How it works","what":"Step 4-1: Prepare RAM matrices","title":"cpptsem","text":"Now parameter values location ctMatrices known, next step relate continuous time parameters data using structural equation models. following matrices required: matrix holds directed effects manifest latent variables S matrix holds (residual) covariances manifest latent variables M vector holds intercepts F matrix separates manifest latent variables matrices generated prepareAMatrix, prepareSMatrix, prepareMMatrix functions. F matrix directly exported ctsem. following, prepareAMatrix function used example; prepareSMatrix, prepareMMatrix work similarly. prepareAMatrix function returns list 4-5 objects (depending model). AnomAuthfit example, : cppAParameterIndicators data frame similar parameter table explained . However, one important distinction: cppAParameterIndicators matrix shows put discrete time parameters matrix: labels column shows names discrete time matrices. instance, discreteDRIFT_1 refers discrete time drift values unique time interval 1. , extracting data ctsem, c++tsem automtically locates repeated time intervals computes corresponding discrete time parameters just . rest columns indicate location discreteDRIFT_1 matrix. Important: Subsetting matrices C++ slightly different R. R mymatrix[1,1] accesses element row 1, column 1 mymatrix. However, C++ counting starts 0. Therefore mymatrix[0,0] accesses element row 1, column 1 mymatrix. prepareAMatrix returns AParameterIndicators cppAParameterIndicators object. discreteDRIFTUnique list best explained first looking : labels correspond unique discrete drift labels cppAParameterIndicators data frame shown . dT refers discrete time interval discrete drift. Finally, matrix unique discrete drifts results stored. discreteTRAITUnique works similarly discreteDRIFTUnique. cppAParameterIndicators data frame also indicates position LAMBDA matrix. LAMBDA can directly exported ctMatrices object requires prior computaion, discreteLAMBDAUnique object. Finally, AInitializer matrix size matrix. c++tsem simply uses matrix mxObject starting point.","code":"mxObject  <- AnomAuthfit$mxobj dataInformation <- regCtsem:::constructDataset(wideData = mxObject$data$observed) Amatrix <- regCtsem:::prepareAMatrix(mxObject = mxObject,                                      ctMatrices = ctMatrices,                                      nlatent = AnomAuthfit$ctmodelobj$n.latent,                                      nmanifest = AnomAuthfit$ctmodelobj$n.manifest,                                     Tpoints = AnomAuthfit$ctmodelobj$Tpoints,                                      dT = dataInformation$dT) names(Amatrix) #> [1] \"discreteDRIFTUnique\"     \"discreteTRAITUnique\"     #> [3] \"AParameterIndicators\"    \"cppAParameterIndicators\" #> [5] \"AInitializer\" Amatrix$cppAParameterIndicators #>              label row_start row_end col_start col_end #> 1  discreteDRIFT_1         2       3         0       1 #> 2  discreteDRIFT_1         4       5         2       3 #> 3  discreteDRIFT_2         6       7         4       5 #> 4  discreteDRIFT_2         8       9         6       7 #> 5  discreteTRAIT_1         2       3        10      11 #> 6  discreteTRAIT_1         4       5        10      11 #> 7  discreteTRAIT_2         6       7        10      11 #> 8  discreteTRAIT_2         8       9        10      11 #> 9           LAMBDA        12      13         0       1 #> 10          LAMBDA        14      15         2       3 #> 11          LAMBDA        16      17         4       5 #> 12          LAMBDA        18      19         6       7 #> 13          LAMBDA        20      21         8       9 Amatrix$discreteDRIFTUnique #> $labels #> [1] \"discreteDRIFT_1\" \"discreteDRIFT_2\" #>  #> $dT #> [1] 1 2 #>  #> $discreteDRIFT_1 #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #>  #> $discreteDRIFT_2 #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0"},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"step-4-2-prepare-kalman-matrices","dir":"Articles","previous_headings":"c++tsem > Advanced: How it works","what":"Step 4-2: Prepare Kalman matrices","title":"cpptsem","text":"first step, discrete time elements (e.g., discreteDRIFTUnique) generated using prepareDiscreteElements function. contrast RAM specification, need , S, M F matrix. discrete time elements work described previus section. function prepareDiscreteElementNames simlply generates discrete time element string vector many elements time intervals indicating unique discrete time parameters use (e.g. dT = c(1, 2, 1, 1) results discreteDRIFT_1, discreteDRIFT_2, discreteDRIFT_1, discreteDRIFT_1). Finally, prepareKalmanMatrices initializes matrix latent scores predicted manifest values.","code":""},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"step-5-1-computeram","dir":"Articles","previous_headings":"c++tsem > Advanced: How it works","what":"Step 5-1: computeRAM","title":"cpptsem","text":"calling computeRAM(), c++tsem : extract continuous time matrices ctMatrices compute discrete time parameters (e.g., discreteDRIFTUnique) fill , S, M matrix discrete time parameters well LAMBDA, T0MEANS, … using cppAParameterIndicators, cppMParameterIndicators, cppSParameterIndicators compute expected means covariancs","code":""},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"step-5-2-fitram","dir":"Articles","previous_headings":"c++tsem > Advanced: How it works","what":"Step 5-2: fitRAM","title":"cpptsem","text":"NOTE: Github support mathematical equations. properly format equations, compy RMarkdown file LaTeX. calling fitRAM(), c++tsem compute -2 log likelihood. end iterate subsamples identical missingness patterns identified prepareRAMData() (see ). single person subsample, -2 log likelihood sample given : \\[-2\\ln\\mathcal{L}(\\mathbf{x}_i) = k_i\\ln(2\\pi)+\\ln(|\\boldsymbol\\Sigma_i|)+(\\mathbf{x}_i-\\boldsymbol\\mu_i)^T\\boldsymbol\\Sigma^{-1}_i(\\mathbf{x}_i-\\boldsymbol\\mu_i)\\] \\(\\) refers person, \\(k_i\\) number non-missing observations person, \\(\\boldsymbol \\Sigma_i\\) filtered expected covariance matrix (rows columns data available person removed) \\(\\mu_i\\) filtered expected means vector (similar filtered covariance). multiple persons subset, simplified likelihood function used. trick used OpenMx extensively speed full information maximum likelihood estimation considerably: \\[\\begin{aligned} -2\\ln\\mathcal{L}(\\mathbf D_g) = N_gk_g\\ln(2\\pi)+N_g\\ln(|\\boldsymbol\\Sigma_g|)+ N_g\\text{tr}(\\mathbf S_g\\boldsymbol\\Sigma^{-1}_g)+ N_g(\\bar{\\mathbf x}-\\boldsymbol\\mu)^T\\boldsymbol\\Sigma^{-1}_g(\\bar{\\mathbf x}_g-\\boldsymbol\\mu_g) \\end{aligned}\\] \\(g\\) stands subset \\(g\\), \\(N_g\\) sample size said subset, \\(k_g\\) number non-missing observations person subset \\(g\\), \\(\\boldsymbol \\Sigma_g\\) denotes filtered expected covariance matrix \\(\\mu_g\\) filtered expected means vector. Finally, \\(\\mathbf S_g = \\frac{1}{N_g}\\sum_{\\g}(\\mathbf{x}_i-\\bar{\\mathbf x}_g)(\\mathbf{x_i}-\\bar{\\mathbf x}_g)^T\\) \\(\\bar{\\mathbf x}_g\\) empirical mean vector subsample g. Finally, -2log-Likelihoods subsamples summed returned.","code":""},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"step-5-3-computeandfitkalman","dir":"Articles","previous_headings":"c++tsem > Advanced: How it works","what":"Step 5-3: computeAndFitKalman","title":"cpptsem","text":"person, latent scores latent state residual covariances first predicted updated. Furthermore, manifest values manifest residual covariances predicted latent scores. predictions used single subject -2 log likelihood function described previous equation. information Kalman filter procedure see Welch, G., & Bishop, G. (2006). Introduction Kalman Filter (Technical Report . 95–041). https://perso.crans.org/club-krobot/doc/kalman.pdf .","code":""},{"path":"https://jhorzek.github.io/regCtsem/articles/cpptsem.html","id":"bibliography","dir":"Articles","previous_headings":"","what":"Bibliography","title":"cpptsem","text":"Boker, S. M., Neale, M. C., Maes, H. H., Wilde, M. J., Spiegel, M., Brick, T. R., Estabrook, R., Bates, T. C., & Mehta, P. (2022). OpenMx: Extended Structural Equation Modelling (2.20.0) [Computer software]. https://cran.r-project.org/web/packages/OpenMx/OpenMx.pdf Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"general-introduction","dir":"Articles","previous_headings":"","what":"General Introduction","title":"regCtsem","text":"Regularized Continuous Time Structural Equation Models (regCtsem) implements least absolute shrinkage selection operator (LASSO; Tibshirani, 1996) adaptive LASSO (Zou, 2006) regularization models following form: \\[ \\begin{aligned} \\text{d}\\pmb{\\eta}(t) &= \\Big(\\pmb \\boldsymbol{\\eta}(t) + \\pmb b + \\pmb\\kappa \\Big) \\text{d} t + \\pmb G\\text d \\pmb W(t)\\\\ \\end{aligned} \\] \\(\\pmb\\eta (t)\\) vector states latent variables \\(\\pmb \\eta\\) time point \\(t\\). \\(\\mathbf \\) drift matrix auto-effects diagonal cross-effects -diagonal, \\(\\pmb b\\) vector continuous time intercepts, \\(\\pmb \\kappa\\) allows trait variance \\(\\pmb G\\) diffusion matrix allows modulation stochastic part model (Wiener process \\(\\mathbf W\\)). latent variables \\(\\pmb \\eta\\) related manifest measurements following measurement equation: \\[ \\pmb y(t_u) = \\pmb d + \\pmb C\\pmb \\eta(t_u) + \\pmb \\varepsilon_{t_u} \\] , \\(\\pmb y(t_u)\\) vector observations time \\(t_u\\) measurement occasion \\(u\\), \\(\\pmb d\\) vector discrete time intercepts, \\(\\pmb C\\) matrix loadings, \\(\\pmb \\varepsilon_{t_u}\\) vector residuals. thorough introduction continuous time structural equation models provided Voelkle et al. (2012). R, models form shown can, instance, fitted packages ctsemOMX ctsem (Driver et al., 2017) regCtsem builds .","code":""},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"regularization","dir":"Articles","previous_headings":"General Introduction","what":"Regularization","title":"regCtsem","text":"regCtsem extends ctsemOMX allowing LASSO adaptive LASSO regularization (see Jacobucci et al., 2016 Huang et al., 2017 introduction regularized SEM). objective function given \\[f(\\pmb\\theta) = L(\\pmb\\theta) + N\\sum_{j\\J}\\lambda_j|\\theta_j - \\tau_j|\\] \\(f(\\pmb\\theta)\\) regularized objective function, \\(L(\\pmb \\theta)\\) -2 log Likelihood model \\(N\\) sample size \\(\\sum_{j\\J}\\lambda_j|\\theta_j - \\tau_j|\\) penalty term. , \\(J\\) set parameter indices \\(\\theta_{j,j\\J}\\) parameters regularized. become clear following examples. penalty term \\(\\tau_j\\) target towards parameter \\(\\theta_j\\) regularized. default set \\(0\\). \\(\\lambda_j\\) controls relative importance -2 log Likelihood penalty term. larger \\(\\lambda_j\\) parameter \\(\\theta_j\\) pulled towards \\(\\tau_j\\). default \\(\\lambda\\) used regularized parameters. shown figure , \\(x\\)-axis shows \\(\\lambda\\) values blue lines two regularized parameters. larger \\(\\lambda\\) pulled towards target \\(0\\).  Using LASSO adaptive LASSO regularization automatically generates models increasing sparsity. Among models can select best generalizing one based cross-validation information criteria.","code":""},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"regCtsem","text":"outlined regCtsem builds ctsemOMX. Many models fitted ctsemOMX can directly passed regCtsem. Therefore, highly recommend familiarize ctsemOMX. basic setup regCtsem expects fitted model ctsemOMX data set wide format well vector names parameters regularized. following example taken documentation ctFit: default regCtsem use 50 different values \\(\\lambda\\). maximally required \\(\\lambda\\) automatically computed (\\(\\lambda_\\max\\)) values \\(0\\) \\(\\lambda_\\max\\) generated getCurvedLambda() (see ?getCurvedLambda). \\(\\lambda\\) values can requested lambdasAutoLength argument (e.g., lambdasAutoLength = 100). Additionally, regCtsem default generating \\(\\lambda\\) values close \\(0\\) less values close \\(\\lambda_\\max\\) (see ?getCurvedLambda). can changed lambdasAutoCurve argument (see ?regCtsem details). Finally, specific \\(\\lambda\\) values can passed function follows: allows “zooming ” specific regions. Let’s plot regularization trajectories:   50 \\(\\lambda\\) values used (default), internally results 50 different models increasing sparsity. important question now best model can found. default regCstem compute AIC BIC models. can accessed : best model can extracted summary function: case unregularized model outperforms regularized models. Alternatively, cross-validation can used. However, end model must refit requesting cross-validation. Depending model number cross-validation sets requested, can take time. Now fit cross-validation given regularizedModel object: Finally, note regCtsem internally translates models C++ (using RcppArmadillo; Eddelbuettel & Sanderson, 2014) function regCtsem::cpptsemFromCtsem (see ?cpptsemFromCtsem). Currently specific model settings ctsemOMX available regCtsem. regCtsem throw error encounters cases.","code":"library(regCtsem) set.seed(38723) ## Directly taken from ?ctFit: ###Example from Voelkle, Oud, Davidov, and Schmidt (2012) - anomia and authoritarianism.   data(AnomAuth)  AnomAuthmodel <- ctModel(LAMBDA = matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2),                           Tpoints = 5, n.latent = 2, n.manifest = 2, MANIFESTVAR=diag(0, 2), TRAITVAR = NULL)  AnomAuthfit <- ctFit(AnomAuth, AnomAuthmodel)  # regularization regularizedModel1 <- regCtsem(ctsemObject = AnomAuthfit,                                dataset = AnomAuth,                                regIndicators = c(\"drift_eta2_eta1\", \"drift_eta1_eta2\")) regularizedModel2 <- regCtsem(ctsemObject = AnomAuthfit,                                dataset = AnomAuth,                               lambdas = seq(0,.1,.01),                               regIndicators = c(\"drift_eta2_eta1\", \"drift_eta1_eta2\")) plot(regularizedModel1) plot(regularizedModel2) regularizedModel1$fit[,1:5] #>                            0 0.00388266682395807 0.00795214091769518 #> regM2LL             23415.93            23418.83            23421.85 #> m2LL                23415.93            23415.94            23415.98 #> AIC                 23443.93            23443.94            23443.98 #> BIC                 23526.66            23526.67            23526.71 #> estimatedParameters    14.00               14.00               14.00 #>                     0.0122174101644433 0.016687894882666 #> regM2LL                       23424.98          23428.23 #> m2LL                          23416.05          23416.16 #> AIC                           23444.05          23444.16 #> BIC                           23526.78          23526.88 #> estimatedParameters              14.00             14.00 summary(regularizedModel1, criterion = \"AIC\") #> [[1]] #> [1] \"|---regCtsem results--------------------------------------------------|\" #>  #> [[2]] #> [1] \"The best AIC value was observed for:\" #>  #> $lambda #> [1] 0 #>  #> [[4]] #> [1] \" --- Parameter estimates: --- \" #>  #> $ParameterEstimates #> DIFFUSION_eta1_eta1 DIFFUSION_eta2_eta1 DIFFUSION_eta2_eta2          drift_eta1  #>          0.47324300         -0.00461089          0.15450974         -0.44728217  #>     drift_eta1_eta2          drift_eta2     drift_eta2_eta1               mm_Y1  #>          0.23249715         -0.11746667          0.04329256          2.68744439  #>               mm_Y2            T0m_eta1            T0m_eta2     T0VAR_eta1_eta1  #>          2.86338104         -0.18401247         -0.02065659          0.63286133  #>     T0VAR_eta2_eta1     T0VAR_eta2_eta2  #>          0.24473121          0.45757744  #>  #> [[6]] #> [1] \" --- Fit: --- \" #>  #> $fit #>             regM2LL                m2LL                 AIC                 BIC  #>            23415.93            23415.93            23443.93            23526.66  #> estimatedParameters  #>               14.00  #>  #> [[8]] #> [1] \"|----------------------------------------------------------------------|\" regularizedModel <- regCtsem(ctsemObject = AnomAuthfit,                               dataset = AnomAuth,                              lambdas = seq(0,.1,.01),                              regIndicators = c(\"drift_eta2_eta1\", \"drift_eta1_eta2\"),                              autoCV = \"kFold\", # k-Fold cross-validation                              k = 3 # k = 3 folds ) regularizedModel$fit[,1:5] #>          [,1]     [,2]     [,3]     [,4]     [,5] #> CV1  7764.468 7764.078 7763.778 7763.518 7763.314 #> CV2  7889.158 7889.651 7890.185 7890.765 7891.380 #> CV3  7789.438 7789.375 7789.357 7789.387 7789.478 #> mean 7814.355 7814.368 7814.440 7814.557 7814.724"},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"lasso-and-adaptive-lasso","dir":"Articles","previous_headings":"Getting Started","what":"LASSO and adaptive LASSO","title":"regCtsem","text":"difficulty LASSO regularized CTSEM \\(\\lambda\\) used regularized parameters. justified regularized parameters units (.e., scale). latent variable models difficult control. , regCtsem offers approximate standardization. end T0-variance asymptotic diffusion can used: Also adaptive LASSO can thought form standardization. default \\(\\lambda_j = \\frac{\\lambda}{|\\hat\\theta_j|}\\), \\(\\hat\\theta_j\\) maximum likelihood estimate \\(\\theta_j\\).","code":"regularizedModel <- regCtsem(ctsemObject = AnomAuthfit,                               dataset = AnomAuth,                              lambdas = seq(0,.1,.01),                              regIndicators = c(\"drift_eta2_eta1\", \"drift_eta1_eta2\"),                              standardizeDrift = \"T0VAR\") regularizedModel <- regCtsem(ctsemObject = AnomAuthfit,                               dataset = AnomAuth,                              lambdas = seq(0,.1,.01),                              regIndicators = c(\"drift_eta2_eta1\", \"drift_eta1_eta2\"),                              standardizeDrift = \"asymptoticDiffusion\") regularizedModel <- regCtsem(ctsemObject = AnomAuthfit,                               dataset = AnomAuth,                              regIndicators = c(\"drift_eta2_eta1\", \"drift_eta1_eta2\"),                              penalty = \"adaptiveLASSO\") plot(regularizedModel)"},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"full-information-maximum-likelihood-and-kalman-filter","dir":"Articles","previous_headings":"Getting Started","what":"Full Information Maximum Likelihood and Kalman Filter","title":"regCtsem","text":"-2 log Likelihood \\(L(\\pmb \\theta)\\) shown can computed Full Information Maximum Likelihood (FIML) procedure Kalman filter. result fit might show different run times. general sample size large, number unique time intervals measurement occasions small, many individuals observed time points FIML much faster. hand sample size small, time intervals unique, large number time points Kalman filter much faster. switch estimation procedures, change objective ctFit first: look run times examples, see , example, FIML lot faster: model fitted Kalman filter ctsemOMX passed regCtsem, regCtsem also use Kalman filter (don’t run following code, take long time): Now, give example Kalman filter excels:","code":"startFIML <- Sys.time() AnomAuthfitFIML <- ctFit(AnomAuth, AnomAuthmodel,                           objective = \"mxRAM\") # Use FIML endFIML <- Sys.time()  startKalman <- Sys.time() AnomAuthfitKalman <- ctFit(AnomAuth, AnomAuthmodel,                             objective = \"Kalman\") # use Kalman filter endKalman <- Sys.time() print(endFIML - startFIML) #> Time difference of 0.8063128 secs print(endKalman - startKalman) #> Time difference of 31.4024 secs regularizedModel <- regCtsem(ctsemObject = AnomAuthfitKalman,                               dataset = AnomAuth,                              regIndicators = c(\"drift_eta2_eta1\", \"drift_eta1_eta2\"),                              penalty = \"adaptiveLASSO\") set.seed(175446)  ## define the population model:  # set the drift matrix. Note that drift eta_1_eta2 is set to equal 0 in the population. ct_drift <- matrix(c(-.3,.2,0,-.5), ncol = 2)  generatingModel<-ctsem::ctModel(Tpoints=100,n.latent=2,                                 n.TDpred=0,n.TIpred=0,n.manifest=2,                                 MANIFESTVAR=diag(0,2),                                 LAMBDA=diag(1,2),                                 DRIFT=ct_drift,                                 DIFFUSION=matrix(c(.5,0,0,.5),2),                                 CINT=matrix(c(0,0),nrow=2),                                 T0MEANS=matrix(0,ncol=1,nrow=2),                                 T0VAR=diag(1,2), type = \"omx\")  # simulate a training data and testing data set traindata <- ctsem::ctGenerate(generatingModel,n.subjects = 10, wide = TRUE)  ## Build the analysis model. Note that drift eta1_eta2 is freely estimated # although it is 0 in the population. myModel <- ctsem::ctModel(Tpoints=100,n.latent=2,n.TDpred=0,                           n.TIpred=0,n.manifest=2,                           LAMBDA=diag(1,2),                           MANIFESTVAR=diag(0,2),                           CINT=matrix(c(0,0),nrow=2),                           DIFFUSION=matrix(c('eta1_eta1',0,0,'eta2_eta2'),2),                           T0MEANS=matrix(0,ncol=1,nrow=2),                           T0VAR=\"auto\", type = \"omx\") fit_myModel <- ctFit(dat = traindata, ctmodelobj = myModel, objective = \"Kalman\")  # select DRIFT values: regIndicators <- c(\"drift_eta2_eta1\", \"drift_eta1_eta2\")  ## Optimization with GIST: regModel <- regCtsem::regCtsem(ctsemObject = fit_myModel,                                dataset = traindata,                                regIndicators = regIndicators,                                lambdasAutoLength = 20 ) plot(regModel)"},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"extracting-the-best-parameters-and-models","dir":"Articles","previous_headings":"Getting Started","what":"Extracting the Best Parameters and Models","title":"regCtsem","text":"best parameters can extracted follows: default, parameters returned raw form; , form implemented internally (e.g., covariances implemented log-Cholesky parameterization; Pinheiro & Bates, 1996). get transformed parameters set raw = FALSE: best model can extracted follows: model implemented C++, many components accessible $ operator:","code":"getFinalParameters(regCtsemObject = regModel,                     criterion = \"AIC\")  #> $criterion #> [1] \"AIC\" #>  #> $lambda #> [1] 3.794832 #>  #> $parameters #>      T0var_eta1      T0var_eta2 T0var_eta2_eta1      drift_eta1 drift_eta1_eta2  #>    -0.299051873    -0.265037440     0.146354259    -0.262008349     0.000000000  #>      drift_eta2 drift_eta2_eta1       eta1_eta1       eta2_eta2           mm_Y1  #>    -0.474233915     0.168628834    -0.699650904    -0.685913204     0.059504253  #>           mm_Y2  #>     0.009090133 getFinalParameters(regCtsemObject = regModel,                     criterion = \"AIC\",                     raw = F)  #> $criterion #> [1] \"AIC\" #>  #> $lambda #> [1] 3.794832 #>  #> $parameters #> DIFFUSION_eta1_eta1 DIFFUSION_eta2_eta1 DIFFUSION_eta2_eta2          drift_eta1  #>         0.245480430         0.000000000         0.255101858        -0.262008349  #>     drift_eta1_eta2          drift_eta2     drift_eta2_eta1               mm_Y1  #>         0.000000000        -0.474233915         0.168628834         0.059504253  #>               mm_Y2     T0VAR_eta1_eta1     T0VAR_eta2_eta1     T0VAR_eta2_eta2  #>         0.009090133         0.553031306         0.109209463         0.613400525 finalModel <- getFinalModel(regCtsemObject = regModel,                              criterion = \"AIC\") #> Best fit for AIC was observed for lambda = 3.79483223498423. finalModel$DRIFTValues #>            [,1]       [,2] #> [1,] -0.2620083  0.0000000 #> [2,]  0.1686288 -0.4742339"},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"saving-and-restoring-models","dir":"Articles","previous_headings":"Getting Started","what":"Saving and Restoring Models","title":"regCtsem","text":"usual objects created regCtsem can saved follows: However, loading model next session underlying C++ object lost. model can restored:","code":"save(regModel, file = \"regModel.RData\") load(\"regModel.RData\") regModel <- restore(regModel)"},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"practical-considerations","dir":"Articles","previous_headings":"Getting Started","what":"Practical Considerations","title":"regCtsem","text":"Fitting regularized CTSEM empirical data can challenging requires several decisions want give guidelines.","code":""},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"selecting-regularized-parameters","dir":"Articles","previous_headings":"Getting Started > Practical Considerations","what":"Selecting Regularized Parameters","title":"regCtsem","text":"general paraemters can regularized regCtsem. unsure parameters might , called model, use following function: function show labels values parameters model. Note lot easier regularize drift values, loadings, manifest latent means. covariance parameters (T0VAR, values \\(\\pmb G\\), manifest variances) implemented log-Cholesky parameterization (Pinheiro & Bates, 1996) might get surprising results regularizing . sure familiarize implementation first attempting regularize (co)variance parameters.","code":"showParameters(fit_myModel) #>              label model        matrix row col        value lbound ubound #> 1       drift_eta1 ctsem         DRIFT   1   1 -0.255694277     NA     NA #> 2  drift_eta1_eta2 ctsem         DRIFT   1   2 -0.021711245     NA     NA #> 3       drift_eta2 ctsem         DRIFT   2   2 -0.482393863     NA     NA #> 4  drift_eta2_eta1 ctsem         DRIFT   2   1  0.185281955     NA     NA #> 5        eta1_eta1 ctsem DIFFUSIONbase   1   1 -0.702270347     NA     NA #> 6        eta2_eta2 ctsem DIFFUSIONbase   2   2 -0.683048161     NA     NA #> 7            mm_Y1 ctsem MANIFESTMEANS   1   1  0.059154164     NA     NA #> 8            mm_Y1 ctsem             D   1   1  0.059154164     NA     NA #> 9            mm_Y2 ctsem MANIFESTMEANS   2   1  0.008901854     NA     NA #> 10           mm_Y2 ctsem             D   2   1  0.008901854     NA     NA #> 11      T0var_eta1 ctsem     T0VARbase   1   1 -0.296170291     NA     NA #> 12      T0var_eta2 ctsem     T0VARbase   2   2 -0.262264074     NA     NA #> 13 T0var_eta2_eta1 ctsem     T0VARbase   2   1  0.146853902     NA     NA"},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"regularizing-towards-specific-values","dir":"Articles","previous_headings":"Getting Started > Practical Considerations","what":"Regularizing Towards Specific Values","title":"regCtsem","text":"mentioned , parameters can also regularized towards values \\(0\\). currently supported GIST optimizer. example: regularized parameters now regularized towards .5:  “#parameters target” refers number parameters target values (.5). Regularizing parameters towards specific targets can used model selected parameters person-specific regularizing towards group value (see Jacobucci & Grimm, 2018 similar approach). feature still experimental, can used follows: group-indicator summary refers individuals data set. Note models take relatively long time run.","code":"regIndicators <- c(\"drift_eta2_eta1\", \"drift_eta1_eta2\") targetVector <- c(\"drift_eta2_eta1\" = .5, \"drift_eta1_eta2\" = .5) regModel <- regCtsem::regCtsem(ctsemObject = fit_myModel,                                dataset = traindata,                                regIndicators = regIndicators,                                lambdasAutoLength = 20,                                targetVector = targetVector ) plot(regModel) regIndicators <- c(\"drift_eta2_eta1\", \"drift_eta1_eta2\") subjectSpecificParameters <- c(\"drift_eta2_eta1\", \"drift_eta1_eta2\") regModel <- regCtsem(ctsemObject = fit_myModel,                      dataset = traindata,                      regIndicators = regIndicators,                      lambdasAutoLength = 5, # 5 will not be enough, but this takes some time to execute                      subjectSpecificParameters = subjectSpecificParameters ) summary(regModel, criterion = \"AIC\") #> [[1]] #> [1] \"|---regCtsem results--------------------------------------------------|\" #>  #> [[2]] #> [1] \"The best AIC value was observed for:\" #>  #> $lambda #> [1] 5.079097 #>  #> [[4]] #> [1] \" --- Parameter estimates: --- \" #>  #> $ParameterEstimates #> $ParameterEstimates$group1 #> DIFFUSION_eta1_eta1 DIFFUSION_eta2_eta1 DIFFUSION_eta2_eta2          drift_eta1  #>         0.244811720         0.000000000         0.253581971        -0.255692783  #>  drift_eta1_eta2_G1          drift_eta2  drift_eta2_eta1_G1               mm_Y1  #>        -0.021711245        -0.482393484         0.185281955         0.059152976  #>               mm_Y2     T0VAR_eta1_eta1     T0VAR_eta2_eta1     T0VAR_eta2_eta2  #>         0.008902174         0.570321136         0.113663059         0.613192886  #>  #> $ParameterEstimates$group2 #> DIFFUSION_eta1_eta1 DIFFUSION_eta2_eta1 DIFFUSION_eta2_eta2          drift_eta1  #>         0.244811720         0.000000000         0.253581971        -0.255692783  #>  drift_eta1_eta2_G2          drift_eta2  drift_eta2_eta1_G2               mm_Y1  #>        -0.021711245        -0.482393484         0.185281955         0.059152976  #>               mm_Y2     T0VAR_eta1_eta1     T0VAR_eta2_eta1     T0VAR_eta2_eta2  #>         0.008902174         0.570321136         0.113663059         0.613192886  #>  #> $ParameterEstimates$group3 #> DIFFUSION_eta1_eta1 DIFFUSION_eta2_eta1 DIFFUSION_eta2_eta2          drift_eta1  #>         0.244811720         0.000000000         0.253581971        -0.255692783  #>  drift_eta1_eta2_G3          drift_eta2  drift_eta2_eta1_G3               mm_Y1  #>        -0.021711245        -0.482393484         0.185281955         0.059152976  #>               mm_Y2     T0VAR_eta1_eta1     T0VAR_eta2_eta1     T0VAR_eta2_eta2  #>         0.008902174         0.570321136         0.113663059         0.613192886  #>  #> $ParameterEstimates$group4 #> DIFFUSION_eta1_eta1 DIFFUSION_eta2_eta1 DIFFUSION_eta2_eta2          drift_eta1  #>         0.244811720         0.000000000         0.253581971        -0.255692783  #>  drift_eta1_eta2_G4          drift_eta2  drift_eta2_eta1_G4               mm_Y1  #>        -0.021711245        -0.482393484         0.185281955         0.059152976  #>               mm_Y2     T0VAR_eta1_eta1     T0VAR_eta2_eta1     T0VAR_eta2_eta2  #>         0.008902174         0.570321136         0.113663059         0.613192886  #>  #> $ParameterEstimates$group5 #> DIFFUSION_eta1_eta1 DIFFUSION_eta2_eta1 DIFFUSION_eta2_eta2          drift_eta1  #>         0.244811720         0.000000000         0.253581971        -0.255692783  #>  drift_eta1_eta2_G5          drift_eta2  drift_eta2_eta1_G5               mm_Y1  #>        -0.021711245        -0.482393484         0.185281955         0.059152976  #>               mm_Y2     T0VAR_eta1_eta1     T0VAR_eta2_eta1     T0VAR_eta2_eta2  #>         0.008902174         0.570321136         0.113663059         0.613192886  #>  #> $ParameterEstimates$group6 #> DIFFUSION_eta1_eta1 DIFFUSION_eta2_eta1 DIFFUSION_eta2_eta2          drift_eta1  #>         0.244811720         0.000000000         0.253581971        -0.255692783  #>  drift_eta1_eta2_G6          drift_eta2  drift_eta2_eta1_G6               mm_Y1  #>        -0.021711245        -0.482393484         0.185281955         0.059152976  #>               mm_Y2     T0VAR_eta1_eta1     T0VAR_eta2_eta1     T0VAR_eta2_eta2  #>         0.008902174         0.570321136         0.113663059         0.613192886  #>  #> $ParameterEstimates$group7 #> DIFFUSION_eta1_eta1 DIFFUSION_eta2_eta1 DIFFUSION_eta2_eta2          drift_eta1  #>         0.244811720         0.000000000         0.253581971        -0.255692783  #>  drift_eta1_eta2_G7          drift_eta2  drift_eta2_eta1_G7               mm_Y1  #>        -0.021711245        -0.482393484         0.185281955         0.059152976  #>               mm_Y2     T0VAR_eta1_eta1     T0VAR_eta2_eta1     T0VAR_eta2_eta2  #>         0.008902174         0.570321136         0.113663059         0.613192886  #>  #> $ParameterEstimates$group8 #> DIFFUSION_eta1_eta1 DIFFUSION_eta2_eta1 DIFFUSION_eta2_eta2          drift_eta1  #>         0.244811720         0.000000000         0.253581971        -0.255692783  #>  drift_eta1_eta2_G8          drift_eta2  drift_eta2_eta1_G8               mm_Y1  #>        -0.021711245        -0.482393484         0.185281955         0.059152976  #>               mm_Y2     T0VAR_eta1_eta1     T0VAR_eta2_eta1     T0VAR_eta2_eta2  #>         0.008902174         0.570321136         0.113663059         0.613192886  #>  #> $ParameterEstimates$group9 #> DIFFUSION_eta1_eta1 DIFFUSION_eta2_eta1 DIFFUSION_eta2_eta2          drift_eta1  #>         0.244811720         0.000000000         0.253581971        -0.255692783  #>  drift_eta1_eta2_G9          drift_eta2  drift_eta2_eta1_G9               mm_Y1  #>        -0.021711245        -0.482393484         0.185281955         0.059152976  #>               mm_Y2     T0VAR_eta1_eta1     T0VAR_eta2_eta1     T0VAR_eta2_eta2  #>         0.008902174         0.570321136         0.113663059         0.613192886  #>  #> $ParameterEstimates$group10 #> DIFFUSION_eta1_eta1 DIFFUSION_eta2_eta1 DIFFUSION_eta2_eta2          drift_eta1  #>         0.244811720         0.000000000         0.253581971        -0.255692783  #> drift_eta1_eta2_G10          drift_eta2 drift_eta2_eta1_G10               mm_Y1  #>        -0.021711245        -0.482393484         0.185281955         0.059152976  #>               mm_Y2     T0VAR_eta1_eta1     T0VAR_eta2_eta1     T0VAR_eta2_eta2  #>         0.008902174         0.570321136         0.113663059         0.613192886  #>  #>  #> [[6]] #> [1] \" Parameters were regularized towards the following values:\" #>  #> $Targets #>  drift_eta2_eta1_G1  drift_eta2_eta1_G2  drift_eta2_eta1_G3  drift_eta2_eta1_G4  #>          0.18528196          0.18528196          0.18528196          0.18528196  #>  drift_eta2_eta1_G5  drift_eta2_eta1_G6  drift_eta2_eta1_G7  drift_eta2_eta1_G8  #>          0.18528196          0.18528196          0.18528196          0.18528196  #>  drift_eta2_eta1_G9 drift_eta2_eta1_G10  drift_eta1_eta2_G1  drift_eta1_eta2_G2  #>          0.18528196          0.18528196         -0.02171125         -0.02171125  #>  drift_eta1_eta2_G3  drift_eta1_eta2_G4  drift_eta1_eta2_G5  drift_eta1_eta2_G6  #>         -0.02171125         -0.02171125         -0.02171125         -0.02171125  #>  drift_eta1_eta2_G7  drift_eta1_eta2_G8  drift_eta1_eta2_G9 drift_eta1_eta2_G10  #>         -0.02171125         -0.02171125         -0.02171125         -0.02171125  #>  #> [[8]] #> [1] \" --- Fit: --- \" #>  #> $fit #>             regM2LL                m2LL                 AIC                 BIC  #>            2241.850            2241.850            2259.850            2262.573  #> estimatedParameters  #>               9.000  #>  #> [[10]] #> [1] \"|----------------------------------------------------------------------|\""},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"avoiding-local-minima","dir":"Articles","previous_headings":"Getting Started > Practical Considerations","what":"Avoiding Local Minima","title":"regCtsem","text":"working real data local minima appear relatively common. regCtsem therefore makes extensive use multiple starting values additionally relies approximating solution established optimizers. safety features come considerable increase runtime adjusting settings can - turn - speed computation price increased risk running local minima. recommend using implemented safety features working empirical data; simulated data observed local minima less common turning safety features might affect results. Turning safety features can done follows:","code":"regularizedModel <- regCtsem(ctsemObject = AnomAuthfit,                               dataset = AnomAuth,                               regIndicators = c(\"drift_eta2_eta1\", \"drift_eta1_eta2\"),                               trainingWheels = FALSE) # switch off all safety features"},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"setting-lambda","dir":"Articles","previous_headings":"Getting Started > Practical Considerations","what":"Setting \\(\\lambda\\)","title":"regCtsem","text":"Selecting reasonable values \\(\\lambda\\) can challenging. general initially running regCtsem limited number \\(\\lambda\\) values \\(0\\) automatically chosen \\(\\lambda_{\\max}\\) can provide good overview. Afterwards rerunning model informed \\(\\lambda\\) values might advisable. number \\(\\lambda\\) values also directly affects runtimes results.","code":""},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"optimziation","dir":"Articles","previous_headings":"Getting Started > Practical Considerations","what":"Optimziation","title":"regCtsem","text":"regCtsem currently supports three different optimization approaches: default use exact optimization. , specific, first use approximate optimization fine tune results exact optimizer. Two different exact optimizers currently supported: GIST (Gong et al., 2013) GLMNET (Friedman et al., 2010, Yuan et al., 2012). cases optimizers return similar results default GIST. However, depending specific data set hand settings optimizer, one might see one outperforming . Switching optimizers can done follows: optimizers can fine tuned. See ?controlGIST ?controlGLMNET details. instance, one might want adjust maximal number outer iterations GIST: approximate optimization provided based Rsolnp (Ghalanos & Theussl, 2015; Ye, 1987) optimx (Nash & Varadhan, 2011). basic specification given : control argument allows fine tuning optimizer. See ?controlApprox details.","code":"regularizedModel <- regCtsem(ctsemObject = AnomAuthfit,                               dataset = AnomAuth,                               regIndicators = c(\"drift_eta2_eta1\", \"drift_eta1_eta2\"),                              optimizer = \"GIST\") regularizedModel <- regCtsem(ctsemObject = AnomAuthfit,                               dataset = AnomAuth,                               regIndicators = c(\"drift_eta2_eta1\", \"drift_eta1_eta2\"),                              optimizer = \"GLMNET\") regularizedModel <- regCtsem(ctsemObject = AnomAuthfit,                               dataset = AnomAuth,                               regIndicators = c(\"drift_eta2_eta1\", \"drift_eta1_eta2\"),                              optimizer = \"GIST\",                              control = controlGIST(maxIter_out = 200)) regularizedModel <- regCtsem(ctsemObject = AnomAuthfit,                               dataset = AnomAuth,                               regIndicators = c(\"drift_eta2_eta1\", \"drift_eta1_eta2\"),                              optimization = \"approx\")"},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"parallelization","dir":"Articles","previous_headings":"Getting Started > Practical Considerations","what":"Parallelization","title":"regCtsem","text":"Given regCtsem can result long runtimes one might want parallelize computation. currently supported package . However, cross-validation used one can start multiple instances scripts pass training validation set manually regCtsem follows: Important: system can use OpenMp, RcppArmadillo might try using cores. can slow optimization currently recommend setting number threads used 1. end, execute following command loading regCtsem:","code":"regularizedModel <- regCtsem(ctsemObject = AnomAuthfit,                               dataset = AnomAuth,                               regIndicators = c(\"drift_eta2_eta1\", \"drift_eta1_eta2\"),                              cvSample = validationSet ) Sys.setenv(OMP_NUM_THREADS = 1)"},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"starting-with-a-sparse-model","dir":"Articles","previous_headings":"Getting Started > Practical Considerations","what":"Starting with a Sparse Model","title":"regCtsem","text":"Sometimes model parameters freely estimated flexible difficult optimize. cases can useful start sparse model; , model regularized parameters already set zero. penalty reduced gradually allow parameters diverge zero. can done follows:  Note combining startFromSparse automatic standardization T0VAR asymptoticDiffusion taken sparse model. reasonable true model assumed relatively similar sparse model, might result poor standardization otherwise.","code":"set.seed(17046)  ## Population model:  # set the drift matrix. Note that drift eta_1_eta2 is set to equal 0 in the population. ct_drift <- matrix(c(-.3,.2,0,-.5), ncol = 2)  generatingModel<-ctsem::ctModel(Tpoints=10,n.latent=2,n.TDpred=0,                                 n.TIpred=0,n.manifest=2,                                 MANIFESTVAR=diag(0,2),                                 LAMBDA=diag(1,2),                                 DRIFT=ct_drift,                                 DIFFUSION=matrix(c(.5,0,0,.5),2),                                 CINT=matrix(c(0,0),nrow=2),                                 T0MEANS=matrix(0,ncol=1,nrow=2),                                 T0VAR=diag(1,2), type = \"omx\")  # simulate a training data set dat <- ctsem::ctGenerate(generatingModel, n.subjects = 100, wide = TRUE)  ## Build the analysis model. Note that drift eta1_eta2 is freely estimated # although it is 0 in the population. myModel <- ctsem::ctModel(Tpoints=10,n.latent=2,n.TDpred=0,                           n.TIpred=0,n.manifest=2,                           LAMBDA=diag(1,2),                           MANIFESTVAR=diag(0,2),                           CINT=matrix(c(0,0),nrow=2),                           DIFFUSION=matrix(c('eta1_eta1',0,0,'eta2_eta2'),2),                           T0MEANS=matrix(0,ncol=1,nrow=2),                           T0VAR=\"auto\", type = \"omx\")  # fit the model using ctsemOMX, but without optimization: fit_myModel <- ctsemOMX::ctFit(dat,                                 myModel,                                 useOptimizer = FALSE)  # select DRIFT values for regularization: regIndicators <- c(\"drift_eta2_eta1\", \"drift_eta1_eta2\")  # Optimize model using GIST with lasso penalty regModel <- regCtsem::startFromSparse(ctsemObject = fit_myModel,                                       dataset = dat,                                       regIndicators = regIndicators,                                       standardizeDrift = \"asymptoticDiffusion\",                                       lambdasAutoLength = 10) regModel$fit plot(regModel)"},{"path":"https://jhorzek.github.io/regCtsem/articles/regCtsem.html","id":"bibliography","dir":"Articles","previous_headings":"","what":"Bibliography","title":"regCtsem","text":"Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05 Eddelbuettel, D., & Sanderson, C. (2014). RcppArmadillo: Accelerating R high-performance C++ linear algebra. Computational Statistics & Data Analysis, 71, 1054–1063. https://doi.org/10.1016/j.csda.2013.02.005 Friedman, J., Hastie, T., & Tibshirani, R. (2010). Regularization Paths Generalized Linear Models via Coordinate Descent. Journal Statistical Software, 33(1), 1–20. https://doi.org/10.18637/jss.v033.i01 Ghalanos, ., & Theussl, S. (2015). Rsolnp: General Non-linear Optimization Using Augmented Lagrange Multiplier Method (R package version 1.16) [Computer software]. Gong, P., Zhang, C., Lu, Z., Huang, J., & Ye, J. (2013). General Iterative Shrinkage Thresholding Algorithm Non-convex Regularized Optimization Problems. Proceedings 30th International Conference Machine Learning, 28(2)(2), 37–45. Huang, P.-H., Chen, H., & Weng, L.-J. (2017). penalized likelihood method structural equation modeling. Psychometrika, 82(2), 329–354. https://doi.org/10.1007/s11336-017-9566-9 Jacobucci, R., & Grimm, K. J. (2018). Regularized Estimation Multivariate Latent Change Score Models. E. Ferrer, S. M. Boker, & K. J. Grimm (Eds.), Longitudinal Multivariate Psychology (1st ed., pp. 109–125). Routledge. https://doi.org/10.4324/9781315160542-6 Jacobucci, R., Grimm, K. J., & McArdle, J. J. (2016). Regularized structural equation modeling. Structural Equation Modeling: Multidisciplinary Journal, 23(4), 555–566. https://doi.org/10.1080/10705511.2016.1154793 Nash, J. C., & Varadhan, R. (2011). Unifying Optimization Algorithms Aid Software System Users: Optimx R. Journal Statistical Software, 43(9), 1–14. https://doi.org/10.18637/jss.v043.i09 Pinheiro, J. C., & Bates, D. M. (1996). Unconstrained parametrizations variance-covariance matrices. Statistics Computing, 6(3), 289–296. https://doi.org/10.1007/BF00140873 Tibshirani, R. (1996). Regression Shrinkage Selection via Lasso. Journal Royal Statistical Society. Series B (Methodological), 58(1), 267–288. Voelkle, M. C., Oud, J. H. L., Davidov, E., & Schmidt, P. (2012). SEM Approach Continuous Time Modeling Panel Data: Relating Authoritarianism Anomia. Psychological Methods, 17(2), 176–192. https://doi.org/10.1037/a0027543 Ye, Y. (1987). Interior Algorithms Linear, Quadratic, Linearly Constrained Non-Linear Programming [Ph.D. Thesis, Department EES, Stanford University.]. https://web.stanford.edu/~yyye/YinyuYePhD.pdf Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421 Zou, H. (2006). Adaptive Lasso Oracle Properties. Journal American Statistical Association, 101(476), 1418–1429. https://doi.org/10.1198/016214506000000735","code":""},{"path":"https://jhorzek.github.io/regCtsem/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":". Maintainer.","code":""},{"path":"https://jhorzek.github.io/regCtsem/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Orzek J (2022). regCtsem: Exact approximate regularization ctsem. R package version 0.1.0, https://jhorzek.github.io/regCtsem/.","code":"@Manual{,   title = {regCtsem: Exact and approximate regularization in ctsem},   author = {Jannik Orzek},   year = {2022},   note = {R package version 0.1.0},   url = {https://jhorzek.github.io/regCtsem/}, }"},{"path":"https://jhorzek.github.io/regCtsem/index.html","id":"regctsem","dir":"","previous_headings":"","what":"Exact and approximate regularization in ctsem","title":"Exact and approximate regularization in ctsem","text":"Regularized Continuous Time Structural Equation Modeling. regCtsem builds ctsemOMX ctsem package (Driver et al., 2017) extends different regularization techniques based Jacobucci et al. (2016) Huang et al. (2017).","code":""},{"path":"https://jhorzek.github.io/regCtsem/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Exact and approximate regularization in ctsem","text":"want install regCtsem GitHub, use following commands R: case also want install vignettes, use:","code":"if(!require(devtools))install.packages(\"devtools\")  devtools::install_github(\"jhorzek/regCtsem\") if(!require(devtools))install.packages(\"devtools\")  devtools::install_github(\"jhorzek/regCtsem\", build_vignettes = TRUE)"},{"path":"https://jhorzek.github.io/regCtsem/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting Started","title":"Exact and approximate regularization in ctsem","text":"good place start help page main function: also installed vignettes, use ``vignette(“regCtsem”, package = “regCtsem”)’’ get examples general guidelines.","code":"?regCtsem::regCtsem"},{"path":"https://jhorzek.github.io/regCtsem/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Exact and approximate regularization in ctsem","text":"Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modeling R Package ctsem. Journal Statistical Software, 77(5). https://doi.org/10.18637/jss.v077.i05 Huang, P.-H., Chen, H., & Weng, L.-J. (2017). Penalized Likelihood Method Structural Equation Modeling. Psychometrika, 82(2), 329–354. https://doi.org/10.1007/s11336-017-9566-9 Jacobucci, R., Grimm, K. J., & McArdle, J. J. (2016). Regularized Structural Equation Modeling. Structural Equation Modeling: Multidisciplinary Journal, 23(4), 555–566. https://doi.org/10.1080/10705511.2016.1154793","code":""},{"path":"https://jhorzek.github.io/regCtsem/index.html","id":"important-notes","dir":"","previous_headings":"","what":"Important Notes","title":"Exact and approximate regularization in ctsem","text":"SOFTWARE PROVIDED ‘’, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/GIST.html","id":null,"dir":"Reference","previous_headings":"","what":"GIST — GIST","title":"GIST — GIST","text":"General Iterative Shrinkage Thresholding Algorithm based Gong, P., Zhang, C., Lu, Z., Huang, J., & Ye, J. (2013). General Iterative Shrinkage Thresholding Algorithm Non-convex Regularized Optimization Problems. S. Dasgupta & D. McAllester (Eds.), Proceedings Machine Learning Research (PMLR; Vol. 28, Issue 2, pp. 37--45). PMLR. http://proceedings.mlr.press","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/GIST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GIST — GIST","text":"","code":"GIST(   cpptsemObject,   startingValues,   objective,   lambda,   adaptiveLassoWeights,   regularizedParameters,   eta,   sig,   initialStepsize,   stepsizeMin,   stepsizeMax,   GISTLinesearchCriterion,   GISTNonMonotoneNBack,   maxIter_out,   maxIter_in,   break_outer,   verbose,   silent )"},{"path":"https://jhorzek.github.io/regCtsem/reference/GIST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GIST — GIST","text":"cpptsemObject model type cpptsem startingValues named vector starting values objective \"ML\" maximum likelihood SEM, \"Kalman\" Kalman filter lambda penalty value adaptiveLassoWeights named vector adaptive lasso weights regularizedParameters named vector regularized parameters eta current step size fails, eta decrease step size. Must > 1 sig Controls sigma parameter Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421, Equation 20. Defaults 0. 0 < sigma < 1 initialStepsize initial stepsize tried outer iteration stepsizeMin Minimal acceptable step size. Must > 0. larger number corresponds smaller step one next iteration. step sizes computed described Gong et al. (2013) stepsizeMax Maximal acceptable step size. Must > stepsizeMin. larger number corresponds smaller step one next iteration. step sizes computed described Gong et al. (2013) GISTLinesearchCriterion criterion accepting step. Possible 'monotone' enforces monotone decrease objective function 'non-monotone' also accepts increase. GISTNonMonotoneNBack case non-monotone line search: Number preceding regM2LL values consider maxIter_out maximal number outer iterations maxIter_in maximal number inner iterations break_outer Stopping criterion outer iterations. named value. default (name: gradient), relative first-order condition checked, maximum absolute value gradients compared break_outer (see https://de.mathworks.com/help/optim/ug/first-order-optimality-measure.html). Alternatively, absolute tolerance can passed function (e.g., break_outer = c(\"gradient\" = .0001)). Instead relative gradients, change parameters can used breaking criterion. end, use c(\"parameterChange\" = .00001) verbose set 1 print additional information plot convergence 2 details. silent suppress warning messages","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/GIST.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"GIST — GIST","text":"GIST minimizes function form f(theta) = l(theta) + g(theta), l likelihood g penalty function. Various penalties supported, however currently lasso adaptive lasso implemented. NOTE: Function located file GIST.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/GISTWithTarget.html","id":null,"dir":"Reference","previous_headings":"","what":"GISTWithTarget — GISTWithTarget","title":"GISTWithTarget — GISTWithTarget","text":"General Iterative Shrinkage Thresholding Algorithm based Gong, P., Zhang, C., Lu, Z., Huang, J., & Ye, J. (2013). General Iterative Shrinkage Thresholding Algorithm Non-convex Regularized Optimization Problems. S. Dasgupta & D. McAllester (Eds.), Proceedings Machine Learning Research (PMLR; Vol. 28, Issue 2, pp. 37--45). PMLR. http://proceedings.mlr.press","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/GISTWithTarget.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GISTWithTarget — GISTWithTarget","text":"","code":"GISTWithTarget(   cpptsemObject,   startingValues,   objective,   lambda,   adaptiveLassoWeights,   regularizedParameters,   targetVector,   eta,   sig,   initialStepsize,   stepsizeMin,   stepsizeMax,   GISTLinesearchCriterion,   GISTNonMonotoneNBack,   maxIter_out,   maxIter_in,   break_outer,   verbose,   silent )"},{"path":"https://jhorzek.github.io/regCtsem/reference/GISTWithTarget.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GISTWithTarget — GISTWithTarget","text":"cpptsemObject model type MxObject compute gradients startingValues named vector starting values objective \"ML\" maximum likelihood SEM, \"Kalman\" Kalman filter lambda penalty value adaptiveLassoWeights named vector adaptive lasso weights regularizedParameters named vector regularized parameters targetVector named vector values towards parameters regularized eta current step size fails, eta decrease step size. Must > 1 sig Controls sigma parameter Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421, Equation 20. Defaults 0. 0 < sigma < 1 initialStepsize initial stepsize tried outer iteration stepsizeMin Minimal acceptable step size. Must > 0. larger number corresponds smaller step one next iteration. step sizes computed described Gong et al. (2013) stepsizeMax Maximal acceptable step size. Must > stepsizeMin. larger number corresponds smaller step one next iteration. step sizes computed described Gong et al. (2013) GISTLinesearchCriterion criterion accepting step. Possible 'monotone' enforces monotone decrease objective function 'non-monotone' also accepts increase. GISTNonMonotoneNBack case non-monotone line search: Number preceding regM2LL values consider maxIter_out maximal number outer iterations maxIter_in maximal number inner iterations break_outer Stopping criterion outer iterations. named value. default (name: gradient), relative first-order condition checked, maximum absolute value gradients compared break_outer (see https://de.mathworks.com/help/optim/ug/first-order-optimality-measure.html). Alternatively, absolute tolerance can passed function (e.g., break_outer = c(\"gradient\" = .0001)). Instead relative gradients, change parameters can used breaking criterion. end, use c(\"parameterChange\" = .00001) verbose set 1 print additional information plot convergence 2 details. silent suppress warning messages","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/GISTWithTarget.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"GISTWithTarget — GISTWithTarget","text":"GIST minimizes function form f(theta) = l(theta) + g(theta), l likelihood g penalty function. Various penalties supported, however currently lasso adaptive lasso implemented. NOTE: Function located file GIST.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_KalmanM2LLCpptsem.html","id":null,"dir":"Reference","previous_headings":"","what":"approx_KalmanM2LLCpptsem — approx_KalmanM2LLCpptsem","title":"approx_KalmanM2LLCpptsem — approx_KalmanM2LLCpptsem","text":"computes -2LogLikelihood approximate optimization regularized ctsem based cpptsem Kalman objective","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_KalmanM2LLCpptsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"approx_KalmanM2LLCpptsem — approx_KalmanM2LLCpptsem","text":"","code":"approx_KalmanM2LLCpptsem(parameters, cpptsemmodel, failureReturns)"},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_KalmanM2LLCpptsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"approx_KalmanM2LLCpptsem — approx_KalmanM2LLCpptsem","text":"parameters paramneter values cpptsemmodel model cpptsem failureReturns value returned regM2LLCpptsem gradCpptsem fails","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_KalmanM2LLCpptsem.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"approx_KalmanM2LLCpptsem — approx_KalmanM2LLCpptsem","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_KalmanRegM2LLCpptsem.html","id":null,"dir":"Reference","previous_headings":"","what":"approx_KalmanRegM2LLCpptsem — approx_KalmanRegM2LLCpptsem","title":"approx_KalmanRegM2LLCpptsem — approx_KalmanRegM2LLCpptsem","text":"approximates regularized likelihood function using cpptsem Kalman","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_KalmanRegM2LLCpptsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"approx_KalmanRegM2LLCpptsem — approx_KalmanRegM2LLCpptsem","text":"","code":"approx_KalmanRegM2LLCpptsem(   parameters,   cpptsemmodel,   adaptiveLassoWeights,   N,   lambda_,   regIndicators,   targetVector,   epsilon,   objective,   failureReturns )"},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_KalmanRegM2LLCpptsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"approx_KalmanRegM2LLCpptsem — approx_KalmanRegM2LLCpptsem","text":"parameters parameter values cpptsemmodel model returned cpptsem adaptiveLassoWeights vector weights adaptive lasso N sample size lambda_ tuning parameter lambda regIndicators string vector names regularized parameters targetVector named vector values towards parameters regularized epsilon tuning parameter epsL1 approximation objective ML Kalman failureReturns value returned regM2LLCpptsem gradCpptsem fails","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_KalmanRegM2LLCpptsem.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"approx_KalmanRegM2LLCpptsem — approx_KalmanRegM2LLCpptsem","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_RAMM2LLCpptsem.html","id":null,"dir":"Reference","previous_headings":"","what":"approx_RAMM2LLCpptsem — approx_RAMM2LLCpptsem","title":"approx_RAMM2LLCpptsem — approx_RAMM2LLCpptsem","text":"computes fit RAM model","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_RAMM2LLCpptsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"approx_RAMM2LLCpptsem — approx_RAMM2LLCpptsem","text":"","code":"approx_RAMM2LLCpptsem(parameters, cpptsemmodel, failureReturns)"},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_RAMM2LLCpptsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"approx_RAMM2LLCpptsem — approx_RAMM2LLCpptsem","text":"parameters parameter values cpptsemmodel model cpptsem failureReturns value returned regM2LLCpptsem gradCpptsem fails","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_RAMM2LLCpptsem.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"approx_RAMM2LLCpptsem — approx_RAMM2LLCpptsem","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_RAMRegM2LLCpptsem.html","id":null,"dir":"Reference","previous_headings":"","what":"approx_RAMRegM2LLCpptsem — approx_RAMRegM2LLCpptsem","title":"approx_RAMRegM2LLCpptsem — approx_RAMRegM2LLCpptsem","text":"approximates regularized likelihood function using cpptsem Full Information Maximum Likelihood","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_RAMRegM2LLCpptsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"approx_RAMRegM2LLCpptsem — approx_RAMRegM2LLCpptsem","text":"","code":"approx_RAMRegM2LLCpptsem(   parameters,   cpptsemmodel,   adaptiveLassoWeights,   N,   lambda_,   regIndicators,   targetVector,   epsilon,   objective,   failureReturns )"},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_RAMRegM2LLCpptsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"approx_RAMRegM2LLCpptsem — approx_RAMRegM2LLCpptsem","text":"parameters parameter values cpptsemmodel model returned cpptsem adaptiveLassoWeights vector weights adaptive lasso N sample size lambda_ tuning parameter lambda regIndicators string vector names regularized parameters targetVector named vector values towards parameters regularized epsilon tuning parameter epsL1 approximation objective ML Kalman failureReturns value returned regM2LLCpptsem gradCpptsem fails","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_RAMRegM2LLCpptsem.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"approx_RAMRegM2LLCpptsem — approx_RAMRegM2LLCpptsem","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_cpptsemOptim.html","id":null,"dir":"Reference","previous_headings":"","what":"approx_cpptsemOptim — approx_cpptsemOptim","title":"approx_cpptsemOptim — approx_cpptsemOptim","text":"creates approximate solution regularized ctsem using optim BFGS","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_cpptsemOptim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"approx_cpptsemOptim — approx_cpptsemOptim","text":"","code":"approx_cpptsemOptim(   cpptsemmodel,   regM2LLCpptsem,   gradCpptsem,   startingValues,   adaptiveLassoWeights,   N,   lambda,   regIndicators,   targetVector,   epsilon,   maxit,   objective,   failureReturns = NA,   testGradients )"},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_cpptsemOptim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"approx_cpptsemOptim — approx_cpptsemOptim","text":"cpptsemmodel model returned cpptsem regM2LLCpptsem regularized fitting function gradCpptsem function computing gradients regM2LLCpptsem startingValues starting values optimization adaptiveLassoWeights vector weights adaptive lasso N sample size lambda tuning parameter lambda regIndicators string vector names regularized parameters targetVector named vector values towards parameters regularized epsilon tuning parameter epsL1 approximation maxit maximal number iterations objective ML Kalman failureReturns value returned regM2LLCpptsem gradCpptsem fails testGradients tested final parameters result NA gradients?","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_cpptsemOptim.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"approx_cpptsemOptim — approx_cpptsemOptim","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_cpptsemOptimx.html","id":null,"dir":"Reference","previous_headings":"","what":"approx_cpptsemOptimx — approx_cpptsemOptimx","title":"approx_cpptsemOptimx — approx_cpptsemOptimx","text":"creates approximate solution regularized ctsem using optimx","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_cpptsemOptimx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"approx_cpptsemOptimx — approx_cpptsemOptimx","text":"","code":"approx_cpptsemOptimx(   cpptsemmodel,   regM2LLCpptsem,   gradCpptsem,   startingValues,   adaptiveLassoWeights,   N,   lambda,   regIndicators,   targetVector,   epsilon,   objective,   testGradients,   controlOptimx,   silent )"},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_cpptsemOptimx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"approx_cpptsemOptimx — approx_cpptsemOptimx","text":"cpptsemmodel model returned cpptsem regM2LLCpptsem regularized fitting function gradCpptsem function computing gradients regM2LLCpptsem startingValues starting values optimization adaptiveLassoWeights vector weights adaptive lasso N sample size lambda tuning parameter lambda regIndicators string vector names regularized parameters targetVector named vector values towards parameters regularized epsilon tuning parameter epsL1 approximation objective ML Kalman testGradients tested final parameters result NA gradients? controlOptimx additional arguments passed control optimx silent suppress warnings","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_cpptsemOptimx.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"approx_cpptsemOptimx — approx_cpptsemOptimx","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_cpptsemRsolnp.html","id":null,"dir":"Reference","previous_headings":"","what":"approx_cpptsemRsolnp — approx_cpptsemRsolnp","title":"approx_cpptsemRsolnp — approx_cpptsemRsolnp","text":"creates approximate solution regularized ctsem using Rsolnp::solnp","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_cpptsemRsolnp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"approx_cpptsemRsolnp — approx_cpptsemRsolnp","text":"","code":"approx_cpptsemRsolnp(   cpptsemmodel,   regM2LLCpptsem,   gradCpptsem,   startingValues,   adaptiveLassoWeights,   N,   lambda,   regIndicators,   targetVector,   epsilon,   objective,   testGradients,   controlRsolnp,   silent )"},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_cpptsemRsolnp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"approx_cpptsemRsolnp — approx_cpptsemRsolnp","text":"cpptsemmodel model returned cpptsem regM2LLCpptsem regularized fitting function gradCpptsem function computing gradients regM2LLCpptsem startingValues starting values optimization adaptiveLassoWeights vector weights adaptive lasso N sample size lambda tuning parameter lambda regIndicators string vector names regularized parameters targetVector named vector values towards parameters regularized epsilon tuning parameter epsL1 approximation objective ML Kalman testGradients tested final parameters result NA gradients? controlRsolnp additional arguments passed control solnp silent suppress warnings","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_cpptsemRsolnp.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"approx_cpptsemRsolnp — approx_cpptsemRsolnp","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_getFitIndices.html","id":null,"dir":"Reference","previous_headings":"","what":"approx_getFitIndices — approx_getFitIndices","title":"approx_getFitIndices — approx_getFitIndices","text":"computes fit indices","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_getFitIndices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"approx_getFitIndices — approx_getFitIndices","text":"","code":"approx_getFitIndices(   m2LL,   regM2LL,   lambda,   parameterValues,   targetVector,   sampleSize,   regIndicators,   returnFitIndices,   zeroThresh )"},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_getFitIndices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"approx_getFitIndices — approx_getFitIndices","text":"m2LL -2 log Likelihood regM2LL regularized -2 log Likelihood lambda tuning parameter lambda parameterValues current parameter values targetVector named vector values towards parameters regularized (Standard regularization towards zero) sampleSize sample size regIndicators matrix ones zeros specifying parameters regOn regularized. Must size regularized matrix. 1 = regularized, 0 = regularized. Alternatively, labels regularized parameters can used (e.g. drift_eta1_eta2) returnFitIndices Boolean: fit indices returned? zeroThresh threshold parameters evaluated == 0 lasso regularization optimization = approx","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_getFitIndices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"approx_getFitIndices — approx_getFitIndices","text":"NOTE: Function located file approx_optimization.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_getFitIndices.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"approx_getFitIndices — approx_getFitIndices","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_gradCpptsem.html","id":null,"dir":"Reference","previous_headings":"","what":"approx_gradCpptsem — approx_gradCpptsem","title":"approx_gradCpptsem — approx_gradCpptsem","text":"computes gradients approximate optimization regularized ctsem based cpptsem","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_gradCpptsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"approx_gradCpptsem — approx_gradCpptsem","text":"","code":"approx_gradCpptsem(   parameters,   cpptsemmodel,   adaptiveLassoWeights,   N,   lambda,   regIndicators,   targetVector,   epsilon,   objective,   failureReturns )"},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_gradCpptsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"approx_gradCpptsem — approx_gradCpptsem","text":"parameters parameter values cpptsemmodel Model type cpptsem adaptiveLassoWeights vector weights adaptive lasso N sample size lambda tuning parameter lambda regIndicators string vector names regularized parameters targetVector named vector values towards parameters regularized epsilon tuning parameter epsL1 approximation objective ML Kalman failureReturns value returned regM2LLCpptsem gradCpptsem fails","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_gradCpptsem.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"approx_gradCpptsem — approx_gradCpptsem","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_iterateOverLambdas.html","id":null,"dir":"Reference","previous_headings":"","what":"approx_iterateOverLambdas — approx_iterateOverLambdas","title":"approx_iterateOverLambdas — approx_iterateOverLambdas","text":"loops lambdas optimization = \"approx\"","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_iterateOverLambdas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"approx_iterateOverLambdas — approx_iterateOverLambdas","text":"","code":"approx_iterateOverLambdas(   cpptsemObject,   dataset,   sampleSize,   regIndicators,   lambdas,   penalty,   adaptiveLassoWeights,   targetVector,   returnFitIndices,   BICWithNAndT,   Tpoints,   objective,   epsilon,   zeroThresh,   controlApproxOptimizer,   scaleLambdaWithN,   verbose )"},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_iterateOverLambdas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"approx_iterateOverLambdas — approx_iterateOverLambdas","text":"cpptsemObject Fitted object type cpptsem dataset wide data set sampleSize sample size regIndicators matrix ones zeros specifying parameters regOn regularized. Must size regularized matrix. 1 = regularized, 0 = regularized. Alternatively, labels regularized parameters can used (e.g. drift_eta1_eta2) lambdas vector penalty values (tuning parameter). E.g., seq(0,1,.01) penalty type. Currently supported lasso ridge optimization = approx lasso optimization = exact adaptiveLassoWeights weights adaptive lasso. targetVector named vector values towards parameters regularized (Standard regularization towards zero) returnFitIndices Boolean: fit indices returned? BICWithNAndT Boolean: TRUE = Use N T formula BIC (-2log L + log(N+T)*k, k number parameters model). FALSE = Use N formula BIC (-2log L + log(N)) Tpoints Number time points (used BICWithNAndT) objective objective used? Possible \"ML\" (Maximum Likelihood) \"Kalman\" (Kalman Filter) epsilon epsilon used transform non-differentiable lasso penalty differentiable one optimization = approx zeroThresh threshold parameters evaluated == 0 lasso regularization optimization = approx controlApproxOptimizer settings passed optimx Rsolnp scaleLambdaWithN Boolean: penalty value scaled sample size? True recommended, likelihood also sample size dependent verbose 0 (default), 1 convergence plot, 2 parameter convergence plot line search progress","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_iterateOverLambdas.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"approx_iterateOverLambdas — approx_iterateOverLambdas","text":"NOTE: Function located file approx_optimization.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_iterateOverLambdas.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"approx_iterateOverLambdas — approx_iterateOverLambdas","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_regCtsem.html","id":null,"dir":"Reference","previous_headings":"","what":"approx_regCtsem — approx_regCtsem","title":"approx_regCtsem — approx_regCtsem","text":"creates regCtsem object approximate optimization","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_regCtsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"approx_regCtsem — approx_regCtsem","text":"","code":"approx_regCtsem(   cpptsemObject,   dataset,   regIndicators,   lambdas,   lambdasAutoLength,   lambdasAutoCurve,   targetVector,   penalty,   adaptiveLassoWeights,   returnFitIndices,   BICWithNAndT,   Tpoints,   cvSampleCpptsemObject,   objective,   epsilon,   zeroThresh,   controlApproxOptimizer,   nMultistart,   scaleLambdaWithN,   verbose )"},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_regCtsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"approx_regCtsem — approx_regCtsem","text":"cpptsemObject Fitted object class cpptsem dataset Please provide data set wide format compatible ctsemOMX regIndicators Labels regularized parameters (e.g. drift_eta1_eta2) lambdas vector penalty values (tuning parameter). E.g., seq(0,1,.01). Alternatively, lambdas can set \"auto\". regCtsem compute upper limit lambda test lambdasAutoLength increasing lambda values lambdasAutoLength lambdas == \"auto\", lambdasAutoLength determine number lambdas tested. lambdasAutoCurve often good idea unequally spaced lambda steps (e.g., .01,.02,.05,1,5,20). lambdasAutoCurve close 1 lambda values equally spaced, lambdasAutoCurve large lambda values concentrated close 0. See ?getCurvedLambda informations. targetVector named vector values towards parameters regularized penalty Currently supported ridge, lasso, adaptiveLasso adaptiveLassoWeights weights adaptive lasso. auto, defaults inverse unregularized parameter estimates. returnFitIndices Boolean: fit indices returned? BICWithNAndT Boolean: TRUE = Use N T formula BIC (-2log L + log(N+T)*k, k number parameters model). FALSE = Use N formula BIC (-2log L + log(N)) Tpoints Number time points (used BICWithNAndT) cvSampleCpptsemObject cppstem cross-validation objective objective used? Possible \"ML\" (Maximum Likelihood) \"Kalman\" (Kalman Filter) epsilon epsilon used transform non-differentiable lasso penalty differentiable one optimization = approx zeroThresh threshold parameters evaluated == 0 lasso regularization optimization = approx controlApproxOptimizer settings passed optimx Rsolnp nMultistart controls many different starting values tried estimating lambda_max scaleLambdaWithN Boolean: penalty value scaled sample size? True recommended, likelihood also sample size dependent verbose 0 (default), 1 convergence plot, 2 parameter convergence plot line search progress","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_regCtsem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"approx_regCtsem — approx_regCtsem","text":"NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/approx_regCtsem.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"approx_regCtsem — approx_regCtsem","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/armaExpmat.html","id":null,"dir":"Reference","previous_headings":"","what":"armaExpmat — armaExpmat","title":"armaExpmat — armaExpmat","text":"Computes matrix exponential using RcppArmadillo","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/armaExpmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"armaExpmat — armaExpmat","text":"","code":"armaExpmat(m)"},{"path":"https://jhorzek.github.io/regCtsem/reference/armaExpmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"armaExpmat — armaExpmat","text":"m symmetric matrix matrix exponential computed","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/armaExpmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"armaExpmat — armaExpmat","text":"matrix","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/checkAutoBlocked.html","id":null,"dir":"Reference","previous_headings":"","what":"checkAutoBlocked — checkAutoBlocked","title":"checkAutoBlocked — checkAutoBlocked","text":"used testthat check automatic k-fold blocked cross-validation feature regCtsem","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/checkAutoBlocked.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"checkAutoBlocked — checkAutoBlocked","text":"","code":"checkAutoBlocked(ctInit, regCtsemObject, threshold, testIC)"},{"path":"https://jhorzek.github.io/regCtsem/reference/checkAutoBlocked.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"checkAutoBlocked — checkAutoBlocked","text":"ctInit init object ctsem regCtsemObject object regCtsem threshold close zero differences treated zero? testIC information criteria tested?","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/checkAutoKFold.html","id":null,"dir":"Reference","previous_headings":"","what":"checkAutoKFold — checkAutoKFold","title":"checkAutoKFold — checkAutoKFold","text":"used testthat check automatic k-fold cross-validation feature regCtsem","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/checkAutoKFold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"checkAutoKFold — checkAutoKFold","text":"","code":"checkAutoKFold(ctInit, regCtsemObject, threshold, testIC)"},{"path":"https://jhorzek.github.io/regCtsem/reference/checkAutoKFold.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"checkAutoKFold — checkAutoKFold","text":"ctInit init object ctsem regCtsemObject object regCtsem threshold close zero differences treated zero? testIC information criteria tested?","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/checkFI.html","id":null,"dir":"Reference","previous_headings":"","what":"checkFI — checkFI","title":"checkFI — checkFI","text":"used testthat check computation fit indices regCtsem","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/checkFI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"checkFI — checkFI","text":"","code":"checkFI(mxObject, regCtsemObject, cvModel = NULL, threshold, testIC)"},{"path":"https://jhorzek.github.io/regCtsem/reference/checkFI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"checkFI — checkFI","text":"mxObject object openmx regCtsemObject object regCtsem cvModel optional cross-validation model threshold close zero differences treated zero? testIC information criteria tested?","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDRIFTHASH.html","id":null,"dir":"Reference","previous_headings":"","what":"computeDRIFTHASH — computeDRIFTHASH","title":"computeDRIFTHASH — computeDRIFTHASH","text":"Computes computeDRIFTHASH given drift. DRIFTHASH = DRIFT otimes + otimes DRIFT.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDRIFTHASH.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeDRIFTHASH — computeDRIFTHASH","text":"","code":"computeDRIFTHASH(DRIFTValues)"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDRIFTHASH.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeDRIFTHASH — computeDRIFTHASH","text":"DRIFTValues matrix drift values","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDRIFTHASH.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"computeDRIFTHASH — computeDRIFTHASH","text":"matrix drift hash","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDRIFTHASH.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"computeDRIFTHASH — computeDRIFTHASH","text":"implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDRIFTHASHExponentials.html","id":null,"dir":"Reference","previous_headings":"","what":"computeDRIFTHASHExponentials — computeDRIFTHASHExponentials","title":"computeDRIFTHASHExponentials — computeDRIFTHASHExponentials","text":"Computes DRIFTHASHExponential discrete time diffusion given drifthash DRIFTHASHExponential (list discrete trait names, dTs results) implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDRIFTHASHExponentials.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeDRIFTHASHExponentials — computeDRIFTHASHExponentials","text":"","code":"computeDRIFTHASHExponentials(DRIFTHASH, DRIFTHASHExponentialUnique)"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDRIFTHASHExponentials.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeDRIFTHASHExponentials — computeDRIFTHASHExponentials","text":"DRIFTHASH matrix drift hash DRIFTHASHExponentialUnique list discrete trait names, dTs results","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDRIFTHASHExponentials.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"computeDRIFTHASHExponentials — computeDRIFTHASHExponentials","text":"list drift hash exponentials","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDiscreteCINTs.html","id":null,"dir":"Reference","previous_headings":"","what":"computeDiscreteCINTs — computeDiscreteCINTs","title":"computeDiscreteCINTs — computeDiscreteCINTs","text":"Computes discrete time latent intercept values (list discreteCINT-names, dTs results) given inverse drift (DRIFTInverseValues), discreteDRIFTUnique (list discreteDRIFT-names, dTs results) CINTValues implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDiscreteCINTs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeDiscreteCINTs — computeDiscreteCINTs","text":"","code":"computeDiscreteCINTs(   discreteCINTUnique,   DRIFTInverseValues,   discreteDRIFTUnique,   CINTValues )"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDiscreteCINTs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeDiscreteCINTs — computeDiscreteCINTs","text":"discreteCINTUnique list unique discrete continuous-time-intercepts DRIFTInverseValues matrix inverse drift values discreteDRIFTUnique list unique discrete drifts CINTValues continuous time intercepts","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDiscreteCINTs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"computeDiscreteCINTs — computeDiscreteCINTs","text":"list updated discrete continuous-time-intercepts","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDiscreteDIFFUSIONs.html","id":null,"dir":"Reference","previous_headings":"","what":"computeDiscreteDIFFUSIONs — computeDiscreteDIFFUSIONs","title":"computeDiscreteDIFFUSIONs — computeDiscreteDIFFUSIONs","text":"Computes discrete time diffusion matrices given DRIFTHASHInverse, DIFFUSION, DRIFTHASHExponentialUnique (list expm(drifthash)-names, dTs results), discreteDIFFUSIONUnique (list diffusion-names, dTs results) implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDiscreteDIFFUSIONs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeDiscreteDIFFUSIONs — computeDiscreteDIFFUSIONs","text":"","code":"computeDiscreteDIFFUSIONs(   DRIFTHASHInverse,   DIFFUSION,   DRIFTHASHExponentialUnique,   discreteDIFFUSIONUnique )"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDiscreteDIFFUSIONs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeDiscreteDIFFUSIONs — computeDiscreteDIFFUSIONs","text":"DRIFTHASHInverse inverse drift matrix DIFFUSION matrix diffusion values DRIFTHASHExponentialUnique list expm(drifthash)-names, dTs results discreteDIFFUSIONUnique list diffusion-names, dTs results","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDiscreteDRIFTs.html","id":null,"dir":"Reference","previous_headings":"","what":"computeDiscreteDRIFTs — computeDiscreteDRIFTs","title":"computeDiscreteDRIFTs — computeDiscreteDRIFTs","text":"Computes discrete time drift matrices given drift discreteDRIFTUnique (list discrete drift names, dTs results) implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDiscreteDRIFTs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeDiscreteDRIFTs — computeDiscreteDRIFTs","text":"","code":"computeDiscreteDRIFTs(DRIFTValues, discreteDRIFTUnique)"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDiscreteDRIFTs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeDiscreteDRIFTs — computeDiscreteDRIFTs","text":"DRIFTValues matrix drift values discreteDRIFTUnique list discrete drift names, dTs results","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDiscreteDRIFTs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"computeDiscreteDRIFTs — computeDiscreteDRIFTs","text":"list","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDiscreteTRAITs.html","id":null,"dir":"Reference","previous_headings":"","what":"computeDiscreteTRAITs — computeDiscreteTRAITs","title":"computeDiscreteTRAITs — computeDiscreteTRAITs","text":"Computes discrete time trait matrices given discreteDRIFTUnique (list discrete drift names, dTs results) discreteTRAITUnique (list discrete trait names, dTs results) implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDiscreteTRAITs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeDiscreteTRAITs — computeDiscreteTRAITs","text":"","code":"computeDiscreteTRAITs(discreteDRIFTUnique, discreteTRAITUnique)"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDiscreteTRAITs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeDiscreteTRAITs — computeDiscreteTRAITs","text":"discreteDRIFTUnique list discrete drift names, dTs results discreteTRAITUnique list discrete trait names, dTs results","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeDiscreteTRAITs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"computeDiscreteTRAITs — computeDiscreteTRAITs","text":"list discrete traits","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeGroupM2LL.html","id":null,"dir":"Reference","previous_headings":"","what":"computeGroupM2LL\nComputes the -2log likelihood in a RAM model for a  group of people with identical missing structure given the sample size, number of non-missing variables (nObservedVariables),\nobservedMeans within this sample, observedCov within this sample, filtered expectedMeans, and filtered expectedCovariance.\nThe implementation closely follows that of Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling With R Package ctsem. Journal of Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05 — computeGroupM2LL","title":"computeGroupM2LL\nComputes the -2log likelihood in a RAM model for a  group of people with identical missing structure given the sample size, number of non-missing variables (nObservedVariables),\nobservedMeans within this sample, observedCov within this sample, filtered expectedMeans, and filtered expectedCovariance.\nThe implementation closely follows that of Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling With R Package ctsem. Journal of Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05 — computeGroupM2LL","text":"computeGroupM2LL Computes -2log likelihood RAM model  group people identical missing structure given sample size, number non-missing variables (nObservedVariables), observedMeans within sample, observedCov within sample, filtered expectedMeans, filtered expectedCovariance. implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeGroupM2LL.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeGroupM2LL\nComputes the -2log likelihood in a RAM model for a  group of people with identical missing structure given the sample size, number of non-missing variables (nObservedVariables),\nobservedMeans within this sample, observedCov within this sample, filtered expectedMeans, and filtered expectedCovariance.\nThe implementation closely follows that of Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling With R Package ctsem. Journal of Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05 — computeGroupM2LL","text":"","code":"computeGroupM2LL(   sampleSize,   nObservedVariables,   observedMeans,   observedCov,   expectedMeans,   expectedCovariance )"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeGroupM2LL.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeGroupM2LL\nComputes the -2log likelihood in a RAM model for a  group of people with identical missing structure given the sample size, number of non-missing variables (nObservedVariables),\nobservedMeans within this sample, observedCov within this sample, filtered expectedMeans, and filtered expectedCovariance.\nThe implementation closely follows that of Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling With R Package ctsem. Journal of Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05 — computeGroupM2LL","text":"sampleSize number persons nObservedVariables number observed variables observedMeans means observed variables observedCov observed covariance expectedMeans expected means expectedCovariance expected covariance","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeGroupM2LL.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"computeGroupM2LL\nComputes the -2log likelihood in a RAM model for a  group of people with identical missing structure given the sample size, number of non-missing variables (nObservedVariables),\nobservedMeans within this sample, observedCov within this sample, filtered expectedMeans, and filtered expectedCovariance.\nThe implementation closely follows that of Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling With R Package ctsem. Journal of Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05 — computeGroupM2LL","text":"double","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeIndividualM2LL.html","id":null,"dir":"Reference","previous_headings":"","what":"computeIndividualM2LL — computeIndividualM2LL","title":"computeIndividualM2LL — computeIndividualM2LL","text":"Computes -2log likelihood RAM model  single person given number non-missing variables (nObservedVariables), x (rawData), filtered expectedMeans, filtered expectedCovariance.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeIndividualM2LL.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeIndividualM2LL — computeIndividualM2LL","text":"","code":"computeIndividualM2LL(   nObservedVariables,   rawData,   expectedMeans,   expectedCovariance )"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeIndividualM2LL.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeIndividualM2LL — computeIndividualM2LL","text":"nObservedVariables number non-missing variables rawData x expectedMeans filtered expectedMeans expectedCovariance filtered expectedCovariance","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeKalmanLatentCovariancePrediction.html","id":null,"dir":"Reference","previous_headings":"","what":"computeKalmanLatentCovariancePrediction — computeKalmanLatentCovariancePrediction","title":"computeKalmanLatentCovariancePrediction — computeKalmanLatentCovariancePrediction","text":"Computes prediction step residual covariance matrix latent states using Kalman filter implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeKalmanLatentCovariancePrediction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeKalmanLatentCovariancePrediction — computeKalmanLatentCovariancePrediction","text":"","code":"computeKalmanLatentCovariancePrediction(   discreteDRIFTValues,   previousCovariances,   discreteDIFFUSIONValues )"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeKalmanLatentCovariancePrediction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeKalmanLatentCovariancePrediction — computeKalmanLatentCovariancePrediction","text":"discreteDRIFTValues discrete drift values previousCovariances covariances previous time point discreteDIFFUSIONValues discrete diffusion values","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeKalmanLatentCovariancePrediction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"computeKalmanLatentCovariancePrediction — computeKalmanLatentCovariancePrediction","text":"predicted covariance","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeKalmanLatentStatePrediction.html","id":null,"dir":"Reference","previous_headings":"","what":"computeKalmanLatentStatePrediction\nComputes the prediction step for the latent states when using the Kalman filter\nThe implementation closely follows that of Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling With R Package ctsem. Journal of Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05 — computeKalmanLatentStatePrediction","title":"computeKalmanLatentStatePrediction\nComputes the prediction step for the latent states when using the Kalman filter\nThe implementation closely follows that of Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling With R Package ctsem. Journal of Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05 — computeKalmanLatentStatePrediction","text":"computeKalmanLatentStatePrediction Computes prediction step latent states using Kalman filter implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeKalmanLatentStatePrediction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeKalmanLatentStatePrediction\nComputes the prediction step for the latent states when using the Kalman filter\nThe implementation closely follows that of Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling With R Package ctsem. Journal of Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05 — computeKalmanLatentStatePrediction","text":"","code":"computeKalmanLatentStatePrediction(   discreteDRIFTValues,   previousStates,   discreteCINTValues )"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeKalmanLatentStatePrediction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeKalmanLatentStatePrediction\nComputes the prediction step for the latent states when using the Kalman filter\nThe implementation closely follows that of Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling With R Package ctsem. Journal of Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05 — computeKalmanLatentStatePrediction","text":"discreteDRIFTValues discrete drift values previousStates states previous time point discreteCINTValues discrete continuous-time-intercept values","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeKalmanLatentStatePrediction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"computeKalmanLatentStatePrediction\nComputes the prediction step for the latent states when using the Kalman filter\nThe implementation closely follows that of Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling With R Package ctsem. Journal of Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05 — computeKalmanLatentStatePrediction","text":"vector predicted states","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeKalmanManifestCovariancePrediction.html","id":null,"dir":"Reference","previous_headings":"","what":"computeKalmanManifestCovariancePrediction — computeKalmanManifestCovariancePrediction","title":"computeKalmanManifestCovariancePrediction — computeKalmanManifestCovariancePrediction","text":"Computes predicted manifest residual covariance matrix given latent residual covariance using Kalman filter implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeKalmanManifestCovariancePrediction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeKalmanManifestCovariancePrediction — computeKalmanManifestCovariancePrediction","text":"","code":"computeKalmanManifestCovariancePrediction(   LAMBDA,   predictedLatentCovariances,   currentMANIFESTVAR )"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeKalmanManifestCovariancePrediction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeKalmanManifestCovariancePrediction — computeKalmanManifestCovariancePrediction","text":"LAMBDA loadings matrix predictedLatentCovariances predicted latent covariances currentMANIFESTVAR current manifest covariance","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeKalmanManifestPrediction.html","id":null,"dir":"Reference","previous_headings":"","what":"computeKalmanManifestPrediction — computeKalmanManifestPrediction","title":"computeKalmanManifestPrediction — computeKalmanManifestPrediction","text":"Computes Prediction manifest variables given predicted latent states using Kalman filter implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeKalmanManifestPrediction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeKalmanManifestPrediction — computeKalmanManifestPrediction","text":"","code":"computeKalmanManifestPrediction(   LAMBDAValues,   predictedStates,   MANIFESTMEANSValues )"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeKalmanManifestPrediction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeKalmanManifestPrediction — computeKalmanManifestPrediction","text":"LAMBDAValues matrix loadings predictedStates vector predicted latent states MANIFESTMEANSValues vector means manifest variables","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeKalmanManifestPrediction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"computeKalmanManifestPrediction — computeKalmanManifestPrediction","text":"predicted manifest values","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeRAMExpectedCovariance.html","id":null,"dir":"Reference","previous_headings":"","what":"computeRAMExpectedCovariance — computeRAMExpectedCovariance","title":"computeRAMExpectedCovariance — computeRAMExpectedCovariance","text":"Computes expected covariance RAM model give filter matrix F, directed effects matrix , covariance matrix S. implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeRAMExpectedCovariance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeRAMExpectedCovariance — computeRAMExpectedCovariance","text":"","code":"computeRAMExpectedCovariance(F, A, S)"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeRAMExpectedCovariance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeRAMExpectedCovariance — computeRAMExpectedCovariance","text":"F filter matrix direct effects matrix S undirected effects matrix","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeRAMExpectedCovariance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"computeRAMExpectedCovariance — computeRAMExpectedCovariance","text":"matrix model implied covariance","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeRAMExpectedMeans.html","id":null,"dir":"Reference","previous_headings":"","what":"computeRAMExpectedMeans — computeRAMExpectedMeans","title":"computeRAMExpectedMeans — computeRAMExpectedMeans","text":"Computes expected means RAM model give filter matrix F, directed effects matrix , means vector M. implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeRAMExpectedMeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeRAMExpectedMeans — computeRAMExpectedMeans","text":"","code":"computeRAMExpectedMeans(F, A, M)"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeRAMExpectedMeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeRAMExpectedMeans — computeRAMExpectedMeans","text":"F filter matrix F matrix directed effects M vector means","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeRAMExpectedMeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"computeRAMExpectedMeans — computeRAMExpectedMeans","text":"matrix implied means","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeRAMM2LL.html","id":null,"dir":"Reference","previous_headings":"","what":"computeRAMM2LL — computeRAMM2LL","title":"computeRAMM2LL — computeRAMM2LL","text":"Computes -2 log Likelihood implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeRAMM2LL.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeRAMM2LL — computeRAMM2LL","text":"","code":"computeRAMM2LL(RAMdata, expectedMeans, expectedCovariance)"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeRAMM2LL.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeRAMM2LL — computeRAMM2LL","text":"RAMdata list data set expectedMeans vector model implied means expectedCovariance matrix model implied covariance","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeRAMM2LL.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"computeRAMM2LL — computeRAMM2LL","text":"double","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeStandardErrorsDelta.html","id":null,"dir":"Reference","previous_headings":"","what":"computeStandardErrorsDelta — computeStandardErrorsDelta","title":"computeStandardErrorsDelta — computeStandardErrorsDelta","text":"computes standard errors transformed parameters cpptsem object","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeStandardErrorsDelta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeStandardErrorsDelta — computeStandardErrorsDelta","text":"","code":"computeStandardErrorsDelta(   cpptsemObject,   objective,   eps = (1.1 * 10^(-16))^(1/3) )"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeStandardErrorsDelta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeStandardErrorsDelta — computeStandardErrorsDelta","text":"cpptsemObject fitted cpptsemObject objective Kalman ML eps epsilon numerical approximation derivatives","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeStandardErrorsDelta.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"computeStandardErrorsDelta — computeStandardErrorsDelta","text":"Jannik H. Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeStandardErrorsRaw.html","id":null,"dir":"Reference","previous_headings":"","what":"computeStandardErrorsRaw — computeStandardErrorsRaw","title":"computeStandardErrorsRaw — computeStandardErrorsRaw","text":"computes standard errors raw parameters cpptsem object","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeStandardErrorsRaw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"computeStandardErrorsRaw — computeStandardErrorsRaw","text":"","code":"computeStandardErrorsRaw(cpptsemObject, objective)"},{"path":"https://jhorzek.github.io/regCtsem/reference/computeStandardErrorsRaw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"computeStandardErrorsRaw — computeStandardErrorsRaw","text":"cpptsemObject fitted cpptsemObject objective Kalman ML","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/computeStandardErrorsRaw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"computeStandardErrorsRaw — computeStandardErrorsRaw","text":"Jannik H. Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/constructDataset.html","id":null,"dir":"Reference","previous_headings":"","what":"constructDataset — constructDataset","title":"constructDataset — constructDataset","text":"Separates data time intervals. Computes number unique time intervals unqiue missingness patterns","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/constructDataset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"constructDataset — constructDataset","text":"","code":"constructDataset(wideData)"},{"path":"https://jhorzek.github.io/regCtsem/reference/constructDataset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"constructDataset — constructDataset","text":"wideData dataset wide format compatible ctsem","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/constructDatasetKalman.html","id":null,"dir":"Reference","previous_headings":"","what":"constructDatasetKalman — constructDatasetKalman","title":"constructDatasetKalman — constructDatasetKalman","text":"Separates data time intervals. Computes number unique time intervals unqiue missingness patterns","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/constructDatasetKalman.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"constructDatasetKalman — constructDatasetKalman","text":"","code":"constructDatasetKalman(wideData)"},{"path":"https://jhorzek.github.io/regCtsem/reference/constructDatasetKalman.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"constructDatasetKalman — constructDatasetKalman","text":"wideData dataset wide format compatible ctsem","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/controlApprox.html","id":null,"dir":"Reference","previous_headings":"","what":"controlApprox — controlApprox","title":"controlApprox — controlApprox","text":"following arguments can used adjust approximate optimization","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/controlApprox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"controlApprox — controlApprox","text":"","code":"controlApprox(   forceCpptsem = FALSE,   epsilon = 0.001,   zeroThresh = 0.04,   nMultistart = 5,   controlApproxOptimizer = controlRsolnp(control = list(outer.iter = 500, trace = 0)) )"},{"path":"https://jhorzek.github.io/regCtsem/reference/controlApprox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"controlApprox — controlApprox","text":"forceCpptsem cpptsem enforced even results differ ctsem? Sometimes differences cpptsem ctsem can result problems numerical precision lead matrix exponential RcppArmadillo differing OpenMx matrix exponential. want ensure faster optimization, set TRUE. See vignette(\"MatrixExponential\", package = \"regCtsem\") details epsilon epsilon used transform non-differentiable lasso penalty differentiable one optimization = approx zeroThresh threshold parameters evaluated == 0 lasso regularization optimization = approx nMultistart controls many different starting values tried estimating lambda_max controlApproxOptimizer settings passed optimizer approximate optimization. Currently, Rsolnp optimx supported. See ?controlOptimx ?controlSolnp details lists passed controlApprox","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/controlGIST.html","id":null,"dir":"Reference","previous_headings":"","what":"controlGIST — controlGIST","title":"controlGIST — controlGIST","text":"following arguments can used adjust GIST optimization. See Gong, P., Zhang, C., Lu, Z., Huang, J., & Ye, J. (2013). General Iterative Shrinkage Thresholding Algorithm Non-convex Regularized Optimization Problems. Proceedings 30th International Conference Machine Learning, 28(2)(2), 37–45. details.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/controlGIST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"controlGIST — controlGIST","text":"","code":"controlGIST(   forceCpptsem = FALSE,   stepSize = 1,   sig = 10^(-5),   maxIter_out = 100,   maxIter_in = 1000,   break_outer = c(fitChange = 10^(-5)),   eta = 2,   stepsizeMin = 1/(10^30),   stepsizeMax = 10^30,   GISTLinesearchCriterion = \"monotone\",   GISTNonMonotoneNBack = 5,   approxFirst = TRUE,   numStart = 0,   nMultistart = 5,   controlApproxOptimizer = controlRsolnp(nudgeVariancesLambda = 0.2, nudgeVariancesTarget     = log(0.4), control = list(outer.iter = 50, trace = 0)) )"},{"path":"https://jhorzek.github.io/regCtsem/reference/controlGIST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"controlGIST — controlGIST","text":"forceCpptsem cpptsem enforced even results differ ctsem? Sometimes differences cpptsem ctsem can result problems numerical precision lead matrix exponential RcppArmadillo differing OpenMx matrix exponential. want ensure faster optimization, set TRUE. See vignette(\"MatrixExponential\", package = \"regCtsem\") details stepSize initial step size outer iteration sig sigma value Gong et al. (2013). Sigma controls inner stopping criterion must (0,1). Generally, larger sigma enforce steeper decrease regularized likelihood smaller sigma result faster acceptance inner iteration. maxIter_out Maximal number outer iterations maxIter_in Maximal number inner iterations break_outer Stopping criterion outer iterations; named value. default change fit used, c(\"fitChange\" = 1e-5) meaning change smaller 1e-5. Additionally, relative change parameters used breaking criterion c(\"parameterChange\" = .00001). Alternatively (name: gradient), relative first-order condition checked, maximum absolute value gradients compared break_outer (see https://de.mathworks.com/help/optim/ug/first-order-optimality-measure.html). Example: c(\"gradient\" = \"max(max(abs(startingValues))*.001, .001)\") . Alternatively, absolute tolerance can passed function (e.g., break_outer = c(\"gradient\" = .0001)). eta current step size fails, eta decrease step size. Must > 1 stepsizeMin Minimal acceptable step size. Must > 0. larger number corresponds smaller step one next iteration. step sizes computed described Gong et al. (2013) stepsizeMax Maximal acceptable step size. Must > stepsizeMin. larger number corresponds smaller step one next iteration. step sizes computed described Gong et al. (2013) GISTLinesearchCriterion criterion accepting step. Possible 'monotone' enforces monotone decrease objective function 'non-monotone' also accepts increase. GISTNonMonotoneNBack case non-monotone line search: Number preceding regM2LL values consider approxFirst approximate optimization used first obtain start values exact optimization? numStart Used approxFirst = 3. regCtsem try numStart+2 starting values (+2 always try current best parameters provided sparseParameters) nMultistart controls many different starting values tried estimating lambda_max controlApproxOptimizer settings passed optimizer approximate optimization. Currently, Rsolnp optimx supported. See ?controlOptimx ?controlSolnp details lists passed controlApprox","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/controlGLMNET.html","id":null,"dir":"Reference","previous_headings":"","what":"controlGLMNET — controlGLMNET","title":"controlGLMNET — controlGLMNET","text":"following arguments can used adjust GLMNET optimization. See Friedman, J., Hastie, T., & Tibshirani, R. (2010). Regularization Paths Generalized Linear Models via Coordinate Descent. Journal Statistical Software, 33(1), 1–20. https://doi.org/10.18637/jss.v033.i01 Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/controlGLMNET.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"controlGLMNET — controlGLMNET","text":"","code":"controlGLMNET(   tryCpptsem = TRUE,   forceCpptsem = FALSE,   stepSize = 1,   lineSearch = \"GLMNET\",   c1 = 1e-04,   c2 = 0.9,   sig = 10^(-5),   gam = 0,   initialHessianApproximation = \"OpenMx\",   maxIter_out = 100,   maxIter_in = 1000,   maxIter_line = 500,   eps_out = 1e-06,   eps_in = 1e-06,   eps_WW = 1e-04,   approxFirst = TRUE,   numStart = 0,   nMultistart = 5,   controlApproxOptimizer = controlRsolnp(nudgeVariancesLambda = 0.2, nudgeVariancesTarget     = log(0.4), control = list(outer.iter = 50, trace = 0)) )"},{"path":"https://jhorzek.github.io/regCtsem/reference/controlGLMNET.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"controlGLMNET — controlGLMNET","text":"tryCpptsem regCtsem try translate model cpptsem? can speed computation considerably might fail models forceCpptsem cpptsem enforced even results differ ctsem? Sometimes differences cpptsem ctsem can result problems numerical precision lead m,atrix exponential RcppArmadillo differing OpenMx matrix exponential. want ensure faster optimization, set TRUE. See vignette(\"MatrixExponential\", package = \"regCtsem\") details stepSize initial step size outer iteration lineSearch String indicating linesearch used. Defaults one described Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421. Alternatively (recommended) Wolfe conditions (lineSearch = \"Wolfe\") can used outer iteration. Setting \"none\" also recommended!. c1 c1 constant lineSearch. constant controls Armijo condition lineSearch lineSearch = \"Wolfe\" c2 c2 constant lineSearch. constant controls Curvature condition lineSearch lineSearch = \"Wolfe\" sig lineSearch = 'GLMNET': Controls sigma parameter Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421, Equation 20. Defaults 0. 0 < sigma < 1 gam lineSearch = 'GLMNET': Controls gamma parameter Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421, Equation 20. Defaults 0. 0 <= gamma < 1 initialHessianApproximation initial hessian approximation used? Possible : 'ident' identity matrix 'OpenMx' (hessian approxmiation mxObject used). Hessian 'OpenMx' positive definite, negative Eigenvalues 'flipped' positive Eigenvalues. works sometimes, always. Alternatively, matrix can provided used initial Hessian maxIter_out Maximal number outer iterations maxIter_in Maximal number inner iterations maxIter_line Maximal number iterations lineSearch procedure eps_out Stopping criterion outer iterations eps_in Stopping criterion inner iterations eps_WW Stopping criterion weak Wolfe line search. upper - lower bound interval < epsWW, line search stopped stepSize returned approxFirst approximate optimization used first obtain start values exact optimization? numStart Used approxFirst = 3. regCtsem try numStart+2 starting values (+2 always try current best parameters provided sparseParameters) nMultistart controls many different starting values tried estimating lambda_max´ controlApproxOptimizer settings passed optimizer approximate optimization. Currently, Rsolnp optimx supported. See ?controlOptimx ?controlSolnp details lists passed controlApprox","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/controlOptimx.html","id":null,"dir":"Reference","previous_headings":"","what":"controlOptimx — controlOptimx","title":"controlOptimx — controlOptimx","text":"list settings used optimization optimx","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/controlOptimx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"controlOptimx — controlOptimx","text":"","code":"controlOptimx(   package = \"optimx\",   nudgeVariancesLambda = 0,   nudgeVariancesTarget = log(0.4),   failureReturns = .Machine$double.xmax/2,   hess = NULL,   lower = -Inf,   upper = Inf,   method = \"L-BFGS-B\",   hessian = FALSE,   itnmax = 200,   control = list(dowarn = FALSE, kkt = TRUE, maxit = 200) )"},{"path":"https://jhorzek.github.io/regCtsem/reference/controlOptimx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"controlOptimx — controlOptimx","text":"package set \"optimx\" nudgeVariancesLambda numeric value >= 0. variances ctsem cpptsem implemented log-Chol decomposition result flat likelihood. can address nudging covariance parameters towards sensible area get better starting values. nudgeVariancesLambda controls strength nudging nudgeVariancesTarget target towards variances nudged. nudgeVariancesTarget target value towards variance estimates nudged approximate optimization. used approximate optimization followed exact optimization. value log(.4) means variance parameters regularized towards .4; note might sensible value specific application. sole purpose nudging get area exp-function exp(x) change x considerable impact exp(x). plot(seq(-10,0,length.= 1000), exp(seq(-10,0,length.= 1000)), type = \"l\") failureReturns fitting function return current points impossible? Depends method used hess Hessian computed solution lower lower bounds paramters upper upper bounds parameters method see ?optimx hessian final hessian computed? itnmax maximal number iterations control control passed optimx","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/controlRsolnp.html","id":null,"dir":"Reference","previous_headings":"","what":"controlRsolnp — controlRsolnp","title":"controlRsolnp — controlRsolnp","text":"list settings used optimization Rsolnp","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/controlRsolnp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"controlRsolnp — controlRsolnp","text":"","code":"controlRsolnp(   package = \"Rsolnp\",   nudgeVariancesLambda = 0,   nudgeVariancesTarget = log(0.4),   failureReturns = .Machine$double.xmax/2,   eqfun = NULL,   eqB = NULL,   ineqfun = NULL,   ineqLB = NULL,   ineqUB = NULL,   LB = NULL,   UB = NULL,   control = list(outer.iter = 50, trace = 0) )"},{"path":"https://jhorzek.github.io/regCtsem/reference/controlRsolnp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"controlRsolnp — controlRsolnp","text":"package set \"Rsolnp\" nudgeVariancesLambda numeric value >= 0. variances ctsem cpptsem implemented log-Chol decomposition result flat likelihood. can address nudging covariance parameters towards sensible area get better starting values. nudgeVariancesLambda controls strength nudging nudgeVariancesTarget target towards variances nudged. nudgeVariancesTarget target value towards variance estimates nudged approximate optimization. used approximate optimization followed exact optimization. value log(.4) means variance parameters regularized towards .4; note might sensible value specific application. sole purpose nudging get area exp-function exp(x) change x considerable impact exp(x). plot(seq(-10,0,length.= 1000), exp(seq(-10,0,length.= 1000)), type = \"l\") failureReturns fitting function return current points impossible? eqfun Equality constraints function. See ?Rsolnp::solnp eqB Equality constraints. See ?Rsolnp::solnp ineqfun Inequality constraints function. See ?Rsolnp::solnp ineqLB Inequality constraints lower bound. See ?Rsolnp::solnp ineqUB Inequality constraints upper bound. See ?Rsolnp::solnp LB Lower bound. See ?Rsolnp::solnp UB Upper bound. See ?Rsolnp::solnp control control passed Rsolnp","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/cpptsemFromCtsem.html","id":null,"dir":"Reference","previous_headings":"","what":"cpptsemFromCtsem — cpptsemFromCtsem","title":"cpptsemFromCtsem — cpptsemFromCtsem","text":"transforms fitted ctsem model cpptsem model. implementation cpptsem closely follows ctsemOMX (Driver et al., 2017)","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/cpptsemFromCtsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"cpptsemFromCtsem — cpptsemFromCtsem","text":"","code":"cpptsemFromCtsem(   ctsemModel,   wideData,   removeD = TRUE,   group = NULL,   groupSpecificParameters = NULL,   silent = FALSE )"},{"path":"https://jhorzek.github.io/regCtsem/reference/cpptsemFromCtsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"cpptsemFromCtsem — cpptsemFromCtsem","text":"ctsemModel fittet ctsem object wideData Please provide data set wide format compatible ctsemOMX removeD removes D matrix mxObject; set TRUE group numeric vector indicating group person belongs groupSpecificParameters string vector indicating parameters group specific silent suppress messages","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/cpptsemFromCtsem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"cpptsemFromCtsem — cpptsemFromCtsem","text":"# References Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/cpptsemFromCtsem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"cpptsemFromCtsem — cpptsemFromCtsem","text":"","code":"if (FALSE) { library(regCtsem)  addCINT <- FALSE if(addCINT){   CINT = matrix(c(\"cint1\", \"cint2\"), nrow = 2, ncol = 1) }else{   CINT = matrix(c(0,0), nrow = 2, ncol = 1) } stationary <- c('T0TRAITEFFECT','T0TIPREDEFFECT')  ## ctsem model without trait AnomAuthmodel1 <- ctModel(LAMBDA = matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2),                           Tpoints = 5, n.latent = 2, n.manifest = 2,                           MANIFESTVAR=diag(0, 2),                           TRAITVAR = NULL,                           CINT = CINT) AnomAuthfit1 <- ctFit(AnomAuth, AnomAuthmodel1, useOptimizer = FALSE, stationary = stationary) AnomAuthfit1$mxobj$fitfunction$result[[1]] gradientModel1 <- OpenMx::mxRun(OpenMx::mxModel(AnomAuthfit1$mxobj,                                                 OpenMx::mxComputeSequence(steps=list(                                                   OpenMx::mxComputeNumericDeriv(checkGradient = FALSE,                                                                                 hessian = FALSE))                                                 ))) centralGrandients <- gradientModel1$compute$steps[[1]]$output[[\"gradient\"]][,\"central\"] names(centralGrandients) <- rownames(gradientModel1$compute$steps[[1]]$output[[\"gradient\"]]) centralGrandients  ## with cpptsem cpptsemmodel1 <- cpptsemFromCtsem(ctsemModel = AnomAuthfit1, wideData = AnomAuth) cpptsemmodel1$computeRAM() cpptsemmodel1$fitRAM() cpptsemmodel1$m2LL cpptsemmodel1$approxRAMGradients((1.1 * 10^(-16))^(1/3))[names(centralGrandients)]  # change parameter values AnomAuthfit1_1 <- ctFit(AnomAuth, AnomAuthmodel1, useOptimizer = TRUE, stationary = stationary) newParameters <- omxGetParameters(AnomAuthfit1_1$mxobj) cpptsemmodel1$setParameterValues(newParameters, names(newParameters)) cpptsemmodel1$computeRAM() cpptsemmodel1$fitRAM() cpptsemmodel1$m2LL  # Compute and compare standard errors ctsemSummary <- summary(AnomAuthfit1_1) ctsemSummary$ctparameters computeStandardErrorsDelta(cpptsemObject = cpptsemmodel1,                            objective = \"ML\")  ## ctsem model with trait AnomAuthmodel2 <- ctModel(LAMBDA = matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2),                           Tpoints = 5, n.latent = 2, n.manifest = 2,                           MANIFESTVAR=diag(0, 2),                           TRAITVAR = \"auto\",                           CINT = CINT) AnomAuthfit2 <- ctFit(AnomAuth, AnomAuthmodel2, useOptimizer = FALSE, stationary = stationary) AnomAuthfit2$mxobj$fitfunction$result[[1]] gradientModel2 <- OpenMx::mxRun(OpenMx::mxModel(AnomAuthfit2$mxobj,                                                 OpenMx::mxComputeSequence(steps=list(                                                   OpenMx::mxComputeNumericDeriv(checkGradient = FALSE,                                                                                 hessian = FALSE))                                                 ))) centralGrandients <- gradientModel2$compute$steps[[1]]$output[[\"gradient\"]][,\"central\"] names(centralGrandients) <- rownames(gradientModel2$compute$steps[[1]]$output[[\"gradient\"]]) centralGrandients ## with cpptsem cpptsemmodel2 <- cpptsemFromCtsem(AnomAuthfit2, wideData = AnomAuth) cpptsemmodel2$computeRAM() cpptsemmodel2$fitRAM() cpptsemmodel2$m2LL cpptsemmodel2$approxRAMGradients((1.1 * 10^(-16))^(1/3))[names(centralGrandients)]   ## Example 3: Kalman Filter set.seed(175446) ## define the population model:  # set the drift matrix. Note that drift eta_1_eta2 is set to equal 0 in the population. ct_drift <- matrix(c(-.3,.2,0,-.5), ncol = 2)  generatingModel<-ctsem::ctModel(Tpoints=20,n.latent=2,n.TDpred=0,n.TIpred=0,n.manifest=2,                                 MANIFESTVAR=diag(0,2),                                 LAMBDA=diag(1,2),                                 DRIFT=ct_drift,                                 DIFFUSION=matrix(c(.5,0,0,.5),2),                                 CINT=matrix(0,nrow = 2, ncol = 1),                                 T0MEANS=matrix(0,ncol=1,nrow=2),                                 T0VAR=diag(1,2), type = \"omx\")  # simulate a training data and testing data set traindata <- ctsem::ctGenerate(generatingModel,n.subjects = 20, wide = TRUE)  ## Build the analysis model. Note that drift eta1_eta2 is freely estimated # although it is 0 in the population. myModel <- ctsem::ctModel(Tpoints=20,n.latent=2,n.TDpred=0,n.TIpred=0,n.manifest=2,                           LAMBDA=diag(1,2),                           MANIFESTVAR=diag(0,2),                           CINT=CINT,                           DIFFUSION=matrix(c('eta1_eta1',0,0,'eta2_eta2'),2),                           T0MEANS=matrix(0,ncol=1,nrow=2),                           T0VAR=\"auto\", type = \"omx\") myModel <- ctFit(myModel, dat = traindata, objective = \"Kalman\", useOptimizer = F, stationary = stationary) myModel$mxobj$fitfunction$result[[1]]  gradientModel3 <- OpenMx::mxRun(OpenMx::mxModel(myModel$mxobj,                                                 OpenMx::mxComputeSequence(steps=list(                                                   OpenMx::mxComputeNumericDeriv(checkGradient = FALSE,                                                                                 hessian = FALSE))                                                 ))) centralGrandients <- gradientModel3$compute$steps[[1]]$output[[\"gradient\"]][,\"central\"] names(centralGrandients) <- rownames(gradientModel3$compute$steps[[1]]$output[[\"gradient\"]]) centralGrandients KalmanScores <- mxKalmanScores(myModel$mxobj) KalmanScores$xUpdated[2:21,]  ## with cpptsem cpptsemmodel3 <- cpptsemFromCtsem(ctsemModel = myModel,wideData = traindata) cpptsemmodel3$computeAndFitKalman(0) # the 0 tells cpptsem that the fit of the full sample should be computed. Passing 1, 2, ... N to the function will compute the fit for a single sample cpptsemmodel3$m2LL cpptsemmodel3$latentScores[1,] cpptsemmodel3$approxKalmanGradients((1.1 * 10^(-16))^(1/3))[names(centralGrandients)]  ## Example 4: Kalman Filter with group or person specific parameter values set.seed(175446) ## define the population model: addCINT <- FALSE if(addCINT){ CINT = matrix(c(\"cint1\", \"cint2\"), nrow = 2, ncol = 1) }else{ CINT = matrix(c(0,0), nrow = 2, ncol = 1) } stationary <- c('T0TRAITEFFECT','T0TIPREDEFFECT') # set the drift matrix. Note that drift eta_1_eta2 is set to equal 0 in the population. ct_drift1 <- matrix(c(-.3,.2,0,-.5), ncol = 2) ct_drift2 <- matrix(c(-.5,.1,.1,-.2), ncol = 2) generatingModel1<-ctsem::ctModel(Tpoints=200,n.latent=2,n.TDpred=0,n.TIpred=0,n.manifest=2,                                  MANIFESTVAR=diag(0,2),                                  LAMBDA=diag(1,2),                                  DRIFT=ct_drift1,                                  DIFFUSION=matrix(c(.5,0,0,.5),2),                                  CINT=matrix(0,nrow = 2, ncol = 1),                                  T0MEANS=matrix(0,ncol=1,nrow=2),                                  T0VAR=diag(1,2), type = \"omx\") generatingModel2<-ctsem::ctModel(Tpoints=200,n.latent=2,n.TDpred=0,n.TIpred=0,n.manifest=2,                                  MANIFESTVAR=diag(0,2),                                  LAMBDA=diag(1,2),                                  DRIFT=ct_drift2,                                  DIFFUSION=matrix(c(.5,0,0,.5),2),                                  CINT=matrix(0,nrow = 2, ncol = 1),                                  T0MEANS=matrix(0,ncol=1,nrow=2),                                  T0VAR=diag(1,2), type = \"omx\") traindata1 <- ctsem::ctGenerate(generatingModel1,n.subjects = 10, wide = TRUE) traindata2 <- ctsem::ctGenerate(generatingModel2,n.subjects = 10, wide = TRUE) traindata <- rbind(traindata1, traindata2) ## Build the analysis model. myModel <- ctsem::ctModel(Tpoints=200,n.latent=2,n.TDpred=0,n.TIpred=0,n.manifest=2,                           LAMBDA=diag(1,2),                           MANIFESTVAR=diag(0,2),                           CINT=CINT,                           DIFFUSION=matrix(c('eta1_eta1',0,0,'eta2_eta2'),2),                           T0MEANS=matrix(0,ncol=1,nrow=2),                           T0VAR=\"auto\", type = \"omx\") myModel <- ctFit(myModel, dat = traindata, objective = \"Kalman\", useOptimizer = F, stationary = stationary)  ## with cpptsem cpptsemmodel3 <- cpptsemFromCtsem(ctsemModel = myModel, wideData = traindata, group = c(rep(1,10), rep(2,10)), groupSpecificParameters = c(myModel$mxobj$DRIFT$labels))  startingValues <- cpptsemmodel3$getParameterValues()  m2LLCpptsem <- function(parameters, cpptsemmodel){   cpptsemmodel$setParameterValues(parameters, names(parameters))   # catching all errors from cpptsemmodel # when parameter values are impossible   invisible(utils::capture.output(KALMAN <- try(cpptsemmodel$computeAndFitKalman(0),                                          silent = TRUE),                            type = \"message\"))    if(class(KALMAN) == \"try-error\" | is.na(cpptsemmodel$m2LL)){     return(99999999)   }   return(cpptsemmodel$m2LL) }  # compute kalmanCpptsemFit <- Rsolnp::solnp(pars = startingValues,                                   fun = m2LLCpptsem,                                   eqfun = NULL, eqB = NULL, ineqfun = NULL, ineqLB = NULL,                                   ineqUB = NULL, LB = NULL, UB = NULL, control = list(trace = 0),                                   cpptsemmodel3) kalmanCpptsemFit$pars ct_drift1 }"},{"path":"https://jhorzek.github.io/regCtsem/reference/createCVFoldsAndModels.html","id":null,"dir":"Reference","previous_headings":"","what":"createCVFoldsAndModels — createCVFoldsAndModels","title":"createCVFoldsAndModels — createCVFoldsAndModels","text":"creates cv folds models","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/createCVFoldsAndModels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"createCVFoldsAndModels — createCVFoldsAndModels","text":"","code":"createCVFoldsAndModels(dataset, Tpoints, manifestNames, k, autoCV, initialPars)"},{"path":"https://jhorzek.github.io/regCtsem/reference/createCVFoldsAndModels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"createCVFoldsAndModels — createCVFoldsAndModels","text":"dataset Please provide data set wide format compatible ctsemOMX Tpoints Number time points manifestNames names manifest variables k number cross-validation folds autoCV = TRUE (k-fold cross-validation) autoCV Form cross-validation: \"kFold\" \"Blocked\" initialPars initial parameters (T0MEANS T0VAR) estimated? , 10 percent initial observations used cross-validation autoCV = \"Blocked\". Otherwise initial parameters poorly estimated","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/createCVFoldsAndModels.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"createCVFoldsAndModels — createCVFoldsAndModels","text":"NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/createCVFoldsAndModels.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"createCVFoldsAndModels — createCVFoldsAndModels","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/createFolds.html","id":null,"dir":"Reference","previous_headings":"","what":"createFolds — createFolds","title":"createFolds — createFolds","text":"created folds automatic cross-validation","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/createFolds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"createFolds — createFolds","text":"","code":"createFolds(sampleSize, k)"},{"path":"https://jhorzek.github.io/regCtsem/reference/createFolds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"createFolds — createFolds","text":"sampleSize sample size k number cross-validation folds (k-fold cross-validation)","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/createFolds.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"createFolds — createFolds","text":"NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/createFolds.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"createFolds — createFolds","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyDataFrame.html","id":null,"dir":"Reference","previous_headings":"","what":"deepCopyDataFrame — deepCopyDataFrame","title":"deepCopyDataFrame — deepCopyDataFrame","text":"deep copy Rcpp data","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyDataFrame.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"deepCopyDataFrame — deepCopyDataFrame","text":"","code":"deepCopyDataFrame(x)"},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyDataFrame.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"deepCopyDataFrame — deepCopyDataFrame","text":"x Rcpp DataFrame","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyDataFrame.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"deepCopyDataFrame — deepCopyDataFrame","text":"copy Rcpp DataFrame","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyList.html","id":null,"dir":"Reference","previous_headings":"","what":"deepCopyList — deepCopyList","title":"deepCopyList — deepCopyList","text":"deep copy Rcpp data","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"deepCopyList — deepCopyList","text":"","code":"deepCopyList(x)"},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"deepCopyList — deepCopyList","text":"x Rcpp List","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"deepCopyList — deepCopyList","text":"copy Rcpp List","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyNumericMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"deepCopyNumericMatrix — deepCopyNumericMatrix","title":"deepCopyNumericMatrix — deepCopyNumericMatrix","text":"deep copy Rcpp data","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyNumericMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"deepCopyNumericMatrix — deepCopyNumericMatrix","text":"","code":"deepCopyNumericMatrix(x)"},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyNumericMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"deepCopyNumericMatrix — deepCopyNumericMatrix","text":"x Rcpp NumericMatrix","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyNumericMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"deepCopyNumericMatrix — deepCopyNumericMatrix","text":"copy Rcpp NumericMatrix","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyNumericVector.html","id":null,"dir":"Reference","previous_headings":"","what":"deepCopyNumericVector — deepCopyNumericVector","title":"deepCopyNumericVector — deepCopyNumericVector","text":"deep copy Rcpp data","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyNumericVector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"deepCopyNumericVector — deepCopyNumericVector","text":"","code":"deepCopyNumericVector(x)"},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyNumericVector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"deepCopyNumericVector — deepCopyNumericVector","text":"x Rcpp NumericVector","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyNumericVector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"deepCopyNumericVector — deepCopyNumericVector","text":"copy Rcpp NumericVector","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyStringMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"deepCopyStringMatrix — deepCopyStringMatrix","title":"deepCopyStringMatrix — deepCopyStringMatrix","text":"deep copy Rcpp data","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyStringMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"deepCopyStringMatrix — deepCopyStringMatrix","text":"","code":"deepCopyStringMatrix(x)"},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyStringMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"deepCopyStringMatrix — deepCopyStringMatrix","text":"x Rcpp StringMatrix","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyStringMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"deepCopyStringMatrix — deepCopyStringMatrix","text":"copy Rcpp StringMatrix","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyStringVector.html","id":null,"dir":"Reference","previous_headings":"","what":"deepCopyStringVector — deepCopyStringVector","title":"deepCopyStringVector — deepCopyStringVector","text":"deep copy Rcpp data","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyStringVector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"deepCopyStringVector — deepCopyStringVector","text":"","code":"deepCopyStringVector(x)"},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyStringVector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"deepCopyStringVector — deepCopyStringVector","text":"x Rcpp StringVector","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/deepCopyStringVector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"deepCopyStringVector — deepCopyStringVector","text":"copy Rcpp StringVector","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_GIST.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_GIST — exact_GIST","title":"exact_GIST — exact_GIST","text":"General Iterative Shrinkage Thresholding Algorithm based Gong, P., Zhang, C., Lu, Z., Huang, J., & Ye, J. (2013). General Iterative Shrinkage Thresholding Algorithm Non-convex Regularized Optimization Problems. S. Dasgupta & D. McAllester (Eds.), Proceedings Machine Learning Research (PMLR; Vol. 28, Issue 2, pp. 37--45). PMLR. http://proceedings.mlr.press","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_GIST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_GIST — exact_GIST","text":"","code":"exact_GIST(   cpptsemObject,   dataset,   objective,   regIndicators,   targetVector,   lambdas,   adaptiveLassoWeights,   sparseParameters,   eta,   sig,   initialStepsize,   stepsizeMin,   stepsizeMax,   GISTLinesearchCriterion,   GISTNonMonotoneNBack,   maxIter_out,   maxIter_in,   break_outer,   scaleLambdaWithN,   sampleSize,   approxFirst,   numStart,   controlApproxOptimizer,   verbose )"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_GIST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_GIST — exact_GIST","text":"cpptsemObject Fitted object class cpptsem dataset required objective = \"Kalman\" ctsemObject type ctsemInit. Please provide data set wide format compatible ctsemOMX objective objective used? Possible \"ML\" (Maximum Likelihood) \"Kalman\" (Kalman Filter) regIndicators Vector names regularized parameters targetVector named vector values towards parameters regularized lambdas Vector lambda values tried adaptiveLassoWeights weights adaptive lasso. sparseParameters labeled vector parameter estimates sparse model. eta current step size fails, eta decrease step size. Must > 1 sig Controls sigma parameter Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421, Equation 20. Defaults 0. 0 < sigma < 1 initialStepsize intial step size tested beginning optimization iteration stepsizeMin Minimal acceptable step size. Must > 0. larger number corresponds smaller step one next iteration. step sizes computed described Gong et al. (2013) stepsizeMax Maximal acceptable step size. Must > stepsizeMin. larger number corresponds smaller step one next iteration. step sizes computed described Gong et al. (2013) GISTLinesearchCriterion criterion accepting step. Possible 'monotone' enforces monotone decrease objective function 'non-monotone' also accepts increase. GISTNonMonotoneNBack case non-monotone line search: Number preceding regM2LL values consider maxIter_out maximal number outer iterations maxIter_in maximal number inner iterations break_outer Stopping criterion outer iterations. named value. default (name: gradient), relative first-order condition checked, maximum absolute value gradients compared break_outer (see https://de.mathworks.com/help/optim/ug/first-order-optimality-measure.html). Alternatively, absolute tolerance can passed function (e.g., break_outer = c(\"gradient\" = .0001)). Instead relative gradients, change parameters can used breaking criterion. end, use c(\"parameterChange\" = .00001) scaleLambdaWithN Boolean: penalty value scaled sample size? True recommended, likelihood also sample size dependent sampleSize sample size scaling lambda N approxFirst approximate optimization used first obtain start values exact optimization? numStart Used approxFirst = 3. regCtsem try numStart+2 starting values (+2 always try current best parameters provided sparseParameters) controlApproxOptimizer settings passed optimx Rsolnp verbose 0 (default), 1 convergence plot, 2 parameter convergence plot line search progress. Set verbose = -1 use C++ implementation GIST (much faster easier handle R implementation default)","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_GIST.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"exact_GIST — exact_GIST","text":"GIST minimizes function form f(theta) = l(theta) + g(theta), l likelihood g penalty function. Various penalties supported, however currently lasso adaptive lasso implemented. NOTE: Function located file GIST.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_GLMNETLineSearch.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_GLMNETLineSearch — exact_GLMNETLineSearch","title":"exact_GLMNETLineSearch — exact_GLMNETLineSearch","text":"performs line search procedure described Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421 Equation 20.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_GLMNETLineSearch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_GLMNETLineSearch — exact_GLMNETLineSearch","text":"","code":"exact_GLMNETLineSearch(   cpptsemObject,   objective,   adaptiveLassoWeights,   parameterLabels,   regIndicators,   lambda,   newParameters,   m2LLNew,   newGradient,   oldHessian,   direction,   stepSize,   sig,   gam,   maxIter_line )"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_GLMNETLineSearch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_GLMNETLineSearch — exact_GLMNETLineSearch","text":"cpptsemObject cpptsem object specifies gradients likelihood-function computed objective objective used? Possible \"ML\" (Maximum Likelihood) \"Kalman\" (Kalman Filter) adaptiveLassoWeights weights adaptive lasso. parameterLabels names parameter estimates regIndicators vector names parameters regularize lambda penalty value newParameters parameter values iteration k plus 1 m2LLNew -2 log likelihood iteration k plus 1 newGradient gradients iteration k plus 1 oldHessian Hessian approximation direction vector updates parameter estimates stepSize Initial stepsize outer iteration (theta_k+1 = oldParameters + Stepsize \\* Stepdirection) sig relevant lineSearch = 'GLMNET'. Controls sigma parameter Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421. gam Controls gamma parameter Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421. Defaults 0. maxIter_line maximal number iterations line search","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_GLMNETLineSearch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"exact_GLMNETLineSearch — exact_GLMNETLineSearch","text":"NOTE: Function located file GLMNET.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_armijoLineSearch.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_armijoLineSearch — exact_armijoLineSearch","title":"exact_armijoLineSearch — exact_armijoLineSearch","text":"performs Armijo line search","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_armijoLineSearch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_armijoLineSearch — exact_armijoLineSearch","text":"","code":"exact_armijoLineSearch(   gradientModel,   adaptiveLassoWeights,   parameterLabels,   regIndicators,   lambda,   newParameters,   m2LLNew,   newGradient,   direction,   c1,   stepSize,   differenceApprox,   maxIter_line )"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_armijoLineSearch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_armijoLineSearch — exact_armijoLineSearch","text":"gradientModel mxObject computing derivarive likelihood respect parameter estimates adaptiveLassoWeights weights adaptive lasso. parameterLabels names parameter estimates regIndicators vector names parameters regularize lambda penalty value newParameters parameter values iteration k plus 1 m2LLNew -2 log likelihood iteration k plus 1 newGradient gradients iteration k plus 1 direction vector updates parameter estimates c1 tuning parameter Armijo condition stepSize Initial stepsize outer iteration (theta_k+1 = oldParameters + Stepsize \\* Stepdirection) differenceApprox approximation gradients used? Recommended central maxIter_line maximal number iterations line search","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_armijoLineSearch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"exact_armijoLineSearch — exact_armijoLineSearch","text":"NOTE: Function located file GLMNET.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_bfgsGLMNET.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_bfgsGLMNET — exact_bfgsGLMNET","title":"exact_bfgsGLMNET — exact_bfgsGLMNET","text":"Performs GLMNET (see Friedman, 2010 & Yuan, 2011) bfgs approximated Hessian","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_bfgsGLMNET.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_bfgsGLMNET — exact_bfgsGLMNET","text":"","code":"exact_bfgsGLMNET(   cpptsemObject,   dataset,   objective,   regIndicators,   lambdas,   adaptiveLassoWeights,   sparseParameters,   stepSize,   lineSearch,   c1,   c2,   sig,   gam,   initialHessianApproximation,   maxIter_out,   maxIter_in,   maxIter_line,   eps_out,   eps_in,   eps_WW,   scaleLambdaWithN,   sampleSize,   approxFirst,   numStart,   controlApproxOptimizer,   extraTries,   verbose )"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_bfgsGLMNET.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_bfgsGLMNET — exact_bfgsGLMNET","text":"cpptsemObject Fitted object class cpptsem dataset required objective = \"Kalman\". Please provide data set wide format compatible ctsemOMX objective objective used? Possible \"ML\" (Maximum Likelihood) \"Kalman\" (Kalman Filter) regIndicators Vector names regularized parameters lambdas Vector lambda values tried adaptiveLassoWeights weights adaptive lasso. sparseParameters labeled vector parameter estimates sparse model. stepSize Initial stepSize outer iteration (theta_k+1 = oldParameters + stepSize * Stepdirection) lineSearch String indicating linesearch used. Defaults one described Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421. Alternatively (recommended) Wolfe conditions (lineSearch = \"Wolfe\") can used outer iteration. Setting \"none\" also recommended!. c1 c1 constant lineSearch. constant controls Armijo condition lineSearch lineSearch = \"Wolfe\" c2 c2 constant lineSearch. constant controls Curvature condition lineSearch lineSearch = \"Wolfe\" sig relevant lineSearch = 'GLMNET'. Controls sigma parameter Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421. gam Controls gamma parameter Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421. Defaults 0. initialHessianApproximation initial hessian approximation used? Possible : 'ident' identity matrix 'OpenMx' (hessian approxmiation mxObject used). Hessian 'OpenMx' positive definite, negative Eigenvalues 'flipped' positive Eigenvalues. works sometimes, always. Alternatively, matrix can provided used initial Hessian maxIter_out Maximal number outer iterations maxIter_in Maximal number inner iterations maxIter_line Maximal number iterations lineSearch procedure eps_out Stopping criterion outer iterations eps_in Stopping criterion inner iterations eps_WW Stopping criterion weak Wolfe line search. upper - lower bound interval < epsWW, line search stopped stepSize returned scaleLambdaWithN Boolean: penalty value scaled sample size? True recommended, likelihood also sample size dependent sampleSize sample size scaling lambda N approxFirst approximate optimization used first obtain start values exact optimization? numStart Used approxFirst = 3. regCtsem try numStart+2 starting values (+2 always try current best parameters provided sparseParameters) controlApproxOptimizer settings passed optimx Rsolnp extraTries number extra tries mxTryHard warm start verbose 0 (default), 1 convergence plot, 2 parameter convergence plot line search progress","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_bfgsGLMNET.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"exact_bfgsGLMNET — exact_bfgsGLMNET","text":"NOTE: Function located file GLMNET.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getBFGS.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_getBFGS — exact_getBFGS","title":"exact_getBFGS — exact_getBFGS","text":"computes BFGS Hessian approximation","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getBFGS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_getBFGS — exact_getBFGS","text":"","code":"exact_getBFGS(   oldParameters,   oldGradients,   oldHessian,   newParameters,   newGradient,   cautious = TRUE,   hessianEps = 0.001 )"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getBFGS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_getBFGS — exact_getBFGS","text":"oldParameters Theta iteration k oldGradients Gradients likelihood function iteration k oldHessian Hessian likelihood function iteration k newParameters Theta iteration k+1 newGradient Gradients likelihood function iteration k+1 cautious boolean: update skipped result non positive definite Hessian? hessianEps controls update Hessian approximation skipped","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getBFGS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"exact_getBFGS — exact_getBFGS","text":"NOTE: Function located file GLMNET.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getCVFit.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_getCVFit — exact_getCVFit","title":"exact_getCVFit — exact_getCVFit","text":"computes cross-validation fit exact optimization.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getCVFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_getCVFit — exact_getCVFit","text":"","code":"exact_getCVFit(   objective,   cvSampleCpptsemObject,   parameterLabels,   parameterValuesTable,   lambdas,   cvSample )"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getCVFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_getCVFit — exact_getCVFit","text":"objective Kalman mx cvSampleCpptsemObject Fitted object class cpptsem parameterLabels labels optimized parameters parameterValuesTable table parameter values+ lambdas vector penalty values (tuning parameter). E.g., seq(0,1,.01) cvSample cross-validation sample. type mxData","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getCVFit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"exact_getCVFit — exact_getCVFit","text":"NOTE: Function located file exact_optimization.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getCVFit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"exact_getCVFit — exact_getCVFit","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getCppGradients.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_getCppGradients — exact_getCppGradients","title":"exact_getCppGradients — exact_getCppGradients","text":"exact_getCppGradients try compute gradients decreasing precision starting default OpenMx. Sometimes gradients result NA specific setting precisions. can help slightly alter precision","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getCppGradients.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_getCppGradients — exact_getCppGradients","text":"","code":"exact_getCppGradients(cpptsemObject, objective)"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getCppGradients.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_getCppGradients — exact_getCppGradients","text":"cpptsemObject model type cpptsem objective ml Kalman","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getFitIndices.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_getFitIndices — exact_getFitIndices","title":"exact_getFitIndices — exact_getFitIndices","text":"computes fit indices optimization = \"exact\"","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getFitIndices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_getFitIndices — exact_getFitIndices","text":"","code":"exact_getFitIndices(parameterLabels, fitAndParameters, lambdas, sampleSize)"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getFitIndices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_getFitIndices — exact_getFitIndices","text":"parameterLabels labels optimized parameters fitAndParameters table fit parameter values lambdas vector penalty values (tuning parameter). E.g., seq(0,1,.01) sampleSize sample size","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getFitIndices.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"exact_getFitIndices — exact_getFitIndices","text":"NOTE: Function located file exact_optimization.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getFitIndices.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"exact_getFitIndices — exact_getFitIndices","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getFitIndicesWithTarget.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_getFitIndicesWithTarget — exact_getFitIndicesWithTarget","title":"exact_getFitIndicesWithTarget — exact_getFitIndicesWithTarget","text":"computes fit indices optimization = \"exact\"","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getFitIndicesWithTarget.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_getFitIndicesWithTarget — exact_getFitIndicesWithTarget","text":"","code":"exact_getFitIndicesWithTarget(   parameterLabels,   regIndicators,   fitAndParameters,   targetVector,   lambdas,   sampleSize )"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getFitIndicesWithTarget.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_getFitIndicesWithTarget — exact_getFitIndicesWithTarget","text":"parameterLabels labels optimized parameters regIndicators Vector names regularized parameters fitAndParameters table fit parameter values targetVector named vector values towards parameters regularized lambdas vector penalty values (tuning parameter). E.g., seq(0,1,.01) sampleSize sample size","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getFitIndicesWithTarget.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"exact_getFitIndicesWithTarget — exact_getFitIndicesWithTarget","text":"NOTE: Function located file exact_optimization.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getFitIndicesWithTarget.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"exact_getFitIndicesWithTarget — exact_getFitIndicesWithTarget","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getPenaltyValue.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_getPenaltyValue — exact_getPenaltyValue","title":"exact_getPenaltyValue — exact_getPenaltyValue","text":"computes sum(lambda*abs(regularized Values))","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getPenaltyValue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_getPenaltyValue — exact_getPenaltyValue","text":"","code":"exact_getPenaltyValue(lambda, theta, regIndicators, adaptiveLassoWeights)"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getPenaltyValue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_getPenaltyValue — exact_getPenaltyValue","text":"lambda Penalty value theta parameter values regIndicators Names regularized parameters adaptiveLassoWeights weights adaptive lasso.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getPenaltyValue.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"exact_getPenaltyValue — exact_getPenaltyValue","text":"NOTE: Function located file exact_optimization.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getPenaltyValueWithTarget.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_getPenaltyValueWithTarget — exact_getPenaltyValueWithTarget","title":"exact_getPenaltyValueWithTarget — exact_getPenaltyValueWithTarget","text":"computes sum(lambda*abs(regularized Values))","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getPenaltyValueWithTarget.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_getPenaltyValueWithTarget — exact_getPenaltyValueWithTarget","text":"","code":"exact_getPenaltyValueWithTarget(   lambda,   theta,   regIndicators,   targetVector,   adaptiveLassoWeights )"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getPenaltyValueWithTarget.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_getPenaltyValueWithTarget — exact_getPenaltyValueWithTarget","text":"lambda Penalty value theta parameter values regIndicators Names regularized parameters targetVector named vector values towards parameters regularized adaptiveLassoWeights weights adaptive lasso.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getPenaltyValueWithTarget.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"exact_getPenaltyValueWithTarget — exact_getPenaltyValueWithTarget","text":"NOTE: Function located file exact_optimization.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getSubgradients.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_getSubgradients — exact_getSubgradients","title":"exact_getSubgradients — exact_getSubgradients","text":"Computes subgradients lasso penalized likelihood f(theta) = L(theta)+lambda*p(theta)","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getSubgradients.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_getSubgradients — exact_getSubgradients","text":"","code":"exact_getSubgradients(   theta,   jacobian,   regIndicators,   lambda,   adaptiveLassoWeightsMatrix )"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getSubgradients.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_getSubgradients — exact_getSubgradients","text":"theta vector named parameters jacobian derivative L(theta) regIndicators names regularized parameters lambda lambda value adaptiveLassoWeightsMatrix matrix adaptive lasso weights","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_getSubgradients.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"exact_getSubgradients — exact_getSubgradients","text":"NOTE: Function located file exact_optimization.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_innerGLMNET.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_innerGLMNET — exact_innerGLMNET","title":"exact_innerGLMNET — exact_innerGLMNET","text":"performs inner optimization routine GLMNET. exact_innerGLMNET returns direction vector next step outer optimization routine.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_innerGLMNET.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_innerGLMNET — exact_innerGLMNET","text":"","code":"exact_innerGLMNET(   adaptiveLassoWeights,   parameterLabels,   regIndicators,   lambda,   newParameters,   newGradient,   HessianNew,   maxIter_in,   eps_in )"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_innerGLMNET.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_innerGLMNET — exact_innerGLMNET","text":"adaptiveLassoWeights weights adaptive lasso. parameterLabels Vector names theta-parameters regIndicators Names regularized parameters lambda Penalty value newParameters Theta iteration k+1 newGradient Gradients likelihood function iteration k+1 HessianNew Hessian likelihood function iteration k+1 maxIter_in Maximal number iterations inner optimization algorithm eps_in Stopping criterion inner iterations","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_innerGLMNET.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"exact_innerGLMNET — exact_innerGLMNET","text":"NOTE: Function located file GLMNET.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_outerGLMNET.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_outerGLMNET — exact_outerGLMNET","title":"exact_outerGLMNET — exact_outerGLMNET","text":"Performs outer iterations GLMNET","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_outerGLMNET.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_outerGLMNET — exact_outerGLMNET","text":"","code":"exact_outerGLMNET(   cpptsemObject,   objective,   adaptiveLassoWeights,   sampleSize,   parameterLabels,   initialParameters,   initialGradients,   initialHessian,   lambda,   regIndicators,   stepSize,   lineSearch,   c1,   c2,   sig,   gam,   maxIter_out,   maxIter_in,   maxIter_line,   eps_out,   eps_in,   eps_WW,   scaleLambdaWithN,   verbose )"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_outerGLMNET.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_outerGLMNET — exact_outerGLMNET","text":"cpptsemObject Object type cpptsem objective objective used? Possible \"ML\" (Maximum Likelihood) \"Kalman\" (Kalman Filter) adaptiveLassoWeights weights adaptive lasso. sampleSize sample size parameterLabels Vector names theta-parameters initialParameters initial parameter estimates initialGradients initial gradients likelihood function initialHessian initial Hessian likelihood function lambda Penalty value regIndicators Names regularized parameters stepSize initial Stepsize outer iteration (theta_k+1 = oldParameters + stepSize \\* Stepdirection) case lineSearch lineSearch String indicating linesearch used. Defaults one described Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421. Alternatively (recommended) Wolfe conditions (lineSearch = \"Wolfe\") can used outer iteration. Setting \"none\" also recommended!. c1 c1 constant lineSearch. constant controls Armijo condition lineSearch lineSearch = \"Wolfe\" c2 c2 constant lineSearch. constant controls Curvature condition lineSearch lineSearch = \"Wolfe\" sig relevant lineSearch = 'GLMNET'. Controls sigma parameter Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421. gam Controls gamma parameter Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999–2030. https://doi.org/10.1145/2020408.2020421. Defaults 0. maxIter_out Maximal number outer iterations maxIter_in Maximal number inner iterations maxIter_line Maximal number iterations lineSearch procedure eps_out Stopping criterion outer iterations eps_in Stopping criterion inner iterations eps_WW Stopping criterion weak Wolfe line search. upper - lower bound interval < epsWW, line search stopped stepSize returned scaleLambdaWithN Boolean: penalty value scaled sample size? True recommended, likelihood also sample size dependent verbose 0 (default), 1 convergence plot, 2 parameter convergence plot line search progress","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_outerGLMNET.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"exact_outerGLMNET — exact_outerGLMNET","text":"NOTE: Function located file GLMNET.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_regCtsem.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_regCtsem — exact_regCtsem","title":"exact_regCtsem — exact_regCtsem","text":"creates regCtsem object exact optimization","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_regCtsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_regCtsem — exact_regCtsem","text":"","code":"exact_regCtsem(   cpptsemObject,   dataset,   regIndicators,   targetVector,   lambdas,   lambdasAutoLength,   lambdasAutoCurve,   penalty,   adaptiveLassoWeights,   returnFitIndices,   BICWithNAndT,   Tpoints,   cvSampleCpptsemObject,   optimizer,   objective,   sparseParameters,   stepSize,   lineSearch,   c1,   c2,   sig,   gam,   initialHessianApproximation,   maxIter_out,   maxIter_in,   maxIter_line,   eps_out,   eps_in,   eps_WW,   eta,   stepsizeMin,   stepsizeMax,   GISTLinesearchCriterion,   GISTNonMonotoneNBack,   break_outer,   scaleLambdaWithN,   approxFirst,   numStart,   nMultistart,   controlApproxOptimizer,   verbose )"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_regCtsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_regCtsem — exact_regCtsem","text":"cpptsemObject Object type cpptsem dataset Please provide data set wide format compatible ctsemOMX regIndicators Labels regularized parameters (e.g. drift_eta1_eta2) targetVector named vector values towards parameters regularized lambdas vector penalty values (tuning parameter). E.g., seq(0,1,.01). Alternatively, lambdas can set \"auto\". regCtsem compute upper limit lambda test lambdasAutoLength increasing lambda values lambdasAutoLength lambdas == \"auto\", lambdasAutoLength determine number lambdas tested. lambdasAutoCurve often good idea unequally spaced lambda steps (e.g., .01,.02,.05,1,5,20). lambdasAutoCurve close 1 lambda values equally spaced, lambdasAutoCurve large lambda values concentrated close 0. See ?getCurvedLambda informations. penalty Currently supported ridge, lasso, adaptiveLasso adaptiveLassoWeights weights adaptive lasso. auto, defaults inverse unregularized parameter estimates. returnFitIndices Boolean: fit indices returned? BICWithNAndT Boolean: TRUE = Use N T formula BIC (-2log L + log(N+T)*k, k number parameters model). FALSE = Use N formula BIC (-2log L + log(N)) Tpoints Number time points (used BICWithNAndT) cvSampleCpptsemObject cppstem cross-validation optimizer Either \"GIST\" \"GLMNET\" objective objective used? Possible \"ML\" (Maximum Likelihood) \"Kalman\" (Kalman Filter) sparseParameters labeled vector parameter estimates sparse model. Required approxFirst = 3. regValues = \"auto\" sparse parameters computed automatically. stepSize GLMNET & GIST: initial step size outer iteration lineSearch GLMNET: String indicating linesearch used. Defaults one described Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999-2030. https://doi.org/10.1145/2020408.2020421. Alternatively (recommended) Wolfe conditions (lineSearch = \"Wolfe\") can used outer iteration. Setting \"none\" also recommended! c1 GLMNET: c1 constant lineSearch. constant controls Armijo condition lineSearch lineSearch = \"Wolfe\" c2 GLMNET: c2 constant lineSearch. constant controls Curvature condition lineSearch lineSearch = \"Wolfe\" sig GLMNET & GIST: GLMNET: relevant lineSearch = 'GLMNET' | GIST: sigma value Gong et al. (2013). Sigma controls inner stopping criterion must (0,1). Generally, larger sigma enforce steeper decrease regularized likelihood smaller sigma result faster acceptance inner iteration. gam GLMNET lineSearch = 'GLMNET'. Controls gamma parameter Yuan, G.-X., Ho, C.-H., & Lin, C.-J. (2012). improved GLMNET l1-regularized logistic regression. Journal Machine Learning Research, 13, 1999-2030. https://doi.org/10.1145/2020408.2020421. Defaults 0. initialHessianApproximation GLMNET: initial hessian approximation used? Possible : 'identity' identity matrix 'OpenMx' (hessian approxmiation mxObject used). Hessian 'OpenMx' positive definite, negative Eigenvalues 'flipped' positive Eigenvalues. \"estimate\" estimate Hessian using optimHess. approaches work time, always. Alternatively, matrix can provided used initial Hessian maxIter_out GLMNET & GIST: Maximal number outer iterations maxIter_in GLMNET & GIST: Maximal number inner iterations maxIter_line GLMNET: Maximal number iterations lineSearch procedure eps_out GLMNET: Stopping criterion outer iterations eps_in GLMNET: Stopping criterion inner iterations eps_WW GLMNET: Stopping criterion weak Wolfe line search. upper - lower bound interval < epsWW, line search stopped stepSize returned eta GIST: current step size fails, eta decrease step size. Must > 1 stepsizeMin GIST: Minimal acceptable step size. Must > 0. larger number corresponds smaller step one next iteration. step sizes computed described Gong et al. (2013) stepsizeMax GIST: Maximal acceptable step size. Must > stepsizeMin. larger number corresponds smaller step one next iteration. step sizes computed described Gong et al. (2013) GISTLinesearchCriterion criterion accepting step. Possible 'monotone' enforces monotone decrease objective function 'non-monotone' also accepts increase. GISTNonMonotoneNBack case non-monotone line search: Number preceding regM2LL values consider break_outer criterion breaking outer iterations GIST. See ?controlGIST information scaleLambdaWithN Boolean: penalty value scaled sample size? True recommended likelihood also sample size dependent approxFirst approximate optimization used first obtain start values exact optimization? numStart Used approxFirst = 3. regCtsem try numStart+2 starting values (+2 always try current best parameters provided sparseParameters) nMultistart controls many different starting values tried estimating lambda_max controlApproxOptimizer settings passed optimx Rsolnp verbose 0 (default), 1 convergence plot, 2 parameter convergence plot line search progress","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_regCtsem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"exact_regCtsem — exact_regCtsem","text":"NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_regCtsem.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"exact_regCtsem — exact_regCtsem","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_tryStartingValues.html","id":null,"dir":"Reference","previous_headings":"","what":"exact_tryStartingValues — exact_tryStartingValues","title":"exact_tryStartingValues — exact_tryStartingValues","text":"tries different starting values find good starting point exact optimization","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_tryStartingValues.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"exact_tryStartingValues — exact_tryStartingValues","text":"","code":"exact_tryStartingValues(   startingValues,   returnAs,   approxFirst,   numStart,   controlApproxOptimizer,   lambda,   cpptsemObject,   regIndicators,   targetVector,   adaptiveLassoWeights,   objective,   sparseParameters )"},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_tryStartingValues.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"exact_tryStartingValues — exact_tryStartingValues","text":"startingValues start values optimization returnAs \"vector\" \"matrix\" approxFirst boolean: solution approximated numStart number starting values controlApproxOptimizer settings passed optimx Rsolnp lambda tuning parameter value cpptsemObject object type cpptsem regIndicators Labels regularized parameters (e.g. drift_eta1_eta2) targetVector named vector values towards parameters regularized adaptiveLassoWeights weights adaptive lasso. objective objective used? Possible \"ML\" (Maximum Likelihood) \"Kalman\" (Kalman Filter) sparseParameters labeled vector parameter estimates sparse model.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_tryStartingValues.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"exact_tryStartingValues — exact_tryStartingValues","text":"NOTE: Function located file exact_optimization.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/exact_tryStartingValues.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"exact_tryStartingValues — exact_tryStartingValues","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/extractCtsemMatrices.html","id":null,"dir":"Reference","previous_headings":"","what":"extractCtsemMatrices — extractCtsemMatrices","title":"extractCtsemMatrices — extractCtsemMatrices","text":"Extract DRIFT, DIFFUSION, etc mxObject","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/extractCtsemMatrices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"extractCtsemMatrices — extractCtsemMatrices","text":"","code":"extractCtsemMatrices(mxObject, nlatent, nmanifest, silent = FALSE)"},{"path":"https://jhorzek.github.io/regCtsem/reference/extractCtsemMatrices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"extractCtsemMatrices — extractCtsemMatrices","text":"mxObject mxObject ctsemOMX nlatent number latent variables nmanifest number manifest variables silent suppress messages","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/extractOptimx.html","id":null,"dir":"Reference","previous_headings":"","what":"extractOptimx — extractOptimx","title":"extractOptimx — extractOptimx","text":"sets model parameters best values obtained optimx","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/extractOptimx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"extractOptimx — extractOptimx","text":"","code":"extractOptimx(parameterLabels, opt)"},{"path":"https://jhorzek.github.io/regCtsem/reference/extractOptimx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"extractOptimx — extractOptimx","text":"parameterLabels vector parameter labels opt result calling psydiffOptimx","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/extractParameterTableFromMx.html","id":null,"dir":"Reference","previous_headings":"","what":"extractParameterTableFromMx — extractParameterTableFromMx","title":"extractParameterTableFromMx — extractParameterTableFromMx","text":"wrapper omxLocateParameters function OpenMx returns data frame parameter labels, location values","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/extractParameterTableFromMx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"extractParameterTableFromMx — extractParameterTableFromMx","text":"","code":"extractParameterTableFromMx(mxObject)"},{"path":"https://jhorzek.github.io/regCtsem/reference/extractParameterTableFromMx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"extractParameterTableFromMx — extractParameterTableFromMx","text":"mxObject Object type mxObject","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/fillA.html","id":null,"dir":"Reference","previous_headings":"","what":"fillA — fillA","title":"fillA — fillA","text":"Fills matrix (directed effects) given matrix, discreteDRIFTUnique (list discrete drift names, dTs results), discreteTRAITUnique (list discrete trait names, dTs results), LAMBDA (loadings), AParameterIndicators (tells fillA put discreteDRIFT, discreteTRAIT, LAMBDA) implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/fillA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"fillA — fillA","text":"","code":"fillA(   A,   hasDiscreteDRIFTUnique,   discreteDRIFTUnique,   hasDiscreteTRAITUnique,   discreteTRAITUnique,   LAMBDA,   AParameterIndicators )"},{"path":"https://jhorzek.github.io/regCtsem/reference/fillA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"fillA — fillA","text":"matrix directed effects hasDiscreteDRIFTUnique boolean discreteDRIFTUnique list discrete drift names, dTs results hasDiscreteTRAITUnique boolean discreteTRAITUnique list discrete trait names, dTs results LAMBDA loadings AParameterIndicators tells fillA put discreteDRIFT, discreteTRAIT, LAMBDA","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/fillM.html","id":null,"dir":"Reference","previous_headings":"","what":"fillM — fillM","title":"fillM — fillM","text":"Fills M vector (intercepts) given M vector, MANIFESTMEANS, discreteCINTUnique (list discrete continuous time intercepts, dTs results), cppMParameterIndicators (tells fillM put MANIFESTMEANS discreteCINT) implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/fillM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"fillM — fillM","text":"","code":"fillM(   M,   T0MEANS,   MANIFESTMEANS,   hasDiscreteCINTUnique,   discreteCINTUnique,   cppMParameterIndicators )"},{"path":"https://jhorzek.github.io/regCtsem/reference/fillM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"fillM — fillM","text":"M vector means T0MEANS vector initial means MANIFESTMEANS manifest means hasDiscreteCINTUnique boolean discreteCINTUnique list discrete continuous time intercepts, dTs results cppMParameterIndicators tells fillM put MANIFESTMEANS discreteCINT","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/fillS.html","id":null,"dir":"Reference","previous_headings":"","what":"fillS — fillS","title":"fillS — fillS","text":"Fills S matrix (covariances) given S matrix, discreteDIFFUSIONUnique (list discrete diffusion names, dTs results), MANIFESTVAR (manifest variance), cppSParameterIndicators (tells fillS put discreteDIFFUSIONUnique MANIFESTVAR) implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/fillS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"fillS — fillS","text":"","code":"fillS(   S,   T0VAR,   MANIFESTVAR,   hasDiscreteTRAITUnique,   TRAITVAR,   hasDiscreteDIFFUSIONUnique,   discreteDIFFUSIONUnique,   SParameterIndicators )"},{"path":"https://jhorzek.github.io/regCtsem/reference/fillS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"fillS — fillS","text":"S matrix undirected effects T0VAR matrix initial covariances MANIFESTVAR manifest variance hasDiscreteTRAITUnique boolean TRAITVAR trait variance hasDiscreteDIFFUSIONUnique boolean discreteDIFFUSIONUnique list discrete diffusion names, dTs results SParameterIndicators tells fillS put discreteDIFFUSIONUnique MANIFESTVAR","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/fitCpptsem.html","id":null,"dir":"Reference","previous_headings":"","what":"fitCpptsem — fitCpptsem","title":"fitCpptsem — fitCpptsem","text":"fits cpptsem. Returns -2 log Likelihood","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/fitCpptsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"fitCpptsem — fitCpptsem","text":"","code":"fitCpptsem(   parameterValues,   cpptsemObject,   objective,   free = labeledFree(parameterValues),   failureReturns )"},{"path":"https://jhorzek.github.io/regCtsem/reference/fitCpptsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"fitCpptsem — fitCpptsem","text":"parameterValues vector labeled parameter values cpptsemObject cpptsem object objective ML Kalman free vector length cpptsemObject$getParameterValues, element specified parameter freely estimated (workaround fixing parameters) failureReturns e.g., NA, Inf, ... adapt optimizer settings","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/generateDRIFTPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"generateDRIFTPlot — generateDRIFTPlot","title":"generateDRIFTPlot — generateDRIFTPlot","text":"generates plot drift values","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/generateDRIFTPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"generateDRIFTPlot — generateDRIFTPlot","text":"","code":"generateDRIFTPlot(   model,   ylab = \"auto\",   xlab = \"auto\",   skiptYlabComp,   skiptXlabComp )"},{"path":"https://jhorzek.github.io/regCtsem/reference/generateDRIFTPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"generateDRIFTPlot — generateDRIFTPlot","text":"model model regCtsem ylab label y-axis. auto set lambda xlab label x-axis. auto set drift skiptYlabComp boolean: ylab string skiptXlabComp boolean: xlab string","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/generateDRIFTPlot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"generateDRIFTPlot — generateDRIFTPlot","text":"NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getAdaptiveLassoWeights.html","id":null,"dir":"Reference","previous_headings":"","what":"getAdaptiveLassoWeights — getAdaptiveLassoWeights","title":"getAdaptiveLassoWeights — getAdaptiveLassoWeights","text":"Computes adaptive lasso weights","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getAdaptiveLassoWeights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getAdaptiveLassoWeights — getAdaptiveLassoWeights","text":"","code":"getAdaptiveLassoWeights(   cpptsemObject,   penalty,   adaptiveLassoWeights,   adaptiveLassoPower,   standardizeDrift )"},{"path":"https://jhorzek.github.io/regCtsem/reference/getAdaptiveLassoWeights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getAdaptiveLassoWeights — getAdaptiveLassoWeights","text":"cpptsemObject Fitted object class cpptsem penalty type adaptiveLassoWeights weights adaptive lasso. adaptiveLassoPower power adaptive lasso weights standardizeDrift Drift parameters standardized automatically? Set '' standardization, 'T0VAR' standardization using T0VAR 'asymptoticDiffusion' standardization using asymptotic diffusion","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getAdaptiveLassoWeights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"getAdaptiveLassoWeights — getAdaptiveLassoWeights","text":"NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getAdaptiveLassoWeights.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"getAdaptiveLassoWeights — getAdaptiveLassoWeights","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getCurvedLambda.html","id":null,"dir":"Reference","previous_headings":"","what":"getCurvedLambda — getCurvedLambda","title":"getCurvedLambda — getCurvedLambda","text":"generates lambda values 0 lambdaMax using function described : https://math.stackexchange.com/questions/384613/exponential-function--values--0--1--x-values--0--1.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getCurvedLambda.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getCurvedLambda — getCurvedLambda","text":"","code":"getCurvedLambda(maxLambda, lambdasAutoCurve, lambdasAutoLength)"},{"path":"https://jhorzek.github.io/regCtsem/reference/getCurvedLambda.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getCurvedLambda — getCurvedLambda","text":"maxLambda maximal lambda value lambdasAutoCurve controls curve. value close 1 result linear increase, larger values lambdas concentrated around 0 lambdasAutoLength number lambda values generate","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getCurvedLambda.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getCurvedLambda — getCurvedLambda","text":"","code":"plot(getCurvedLambda(10,1,100)) plot(getCurvedLambda(10,5,100)) plot(getCurvedLambda(10,100,100))"},{"path":"https://jhorzek.github.io/regCtsem/reference/getFinalModel.html","id":null,"dir":"Reference","previous_headings":"","what":"getFinalModel — getFinalModel","title":"getFinalModel — getFinalModel","text":"returns final model regularized model. Note: Returns mxObject!","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getFinalModel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getFinalModel — getFinalModel","text":"","code":"getFinalModel(regCtsemObject, criterion)"},{"path":"https://jhorzek.github.io/regCtsem/reference/getFinalModel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getFinalModel — getFinalModel","text":"regCtsemObject fitted regularized continuous time model criterion select criterion. Possible AIC, BIC, cvM2LL","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getFinalModel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"getFinalModel — getFinalModel","text":"NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getFinalModel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"getFinalModel — getFinalModel","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getFinalParameters.html","id":null,"dir":"Reference","previous_headings":"","what":"getFinalParameters — getFinalParameters","title":"getFinalParameters — getFinalParameters","text":"returns final parameters regularized model","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getFinalParameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getFinalParameters — getFinalParameters","text":"","code":"getFinalParameters(regCtsemObject, criterion, raw = TRUE)"},{"path":"https://jhorzek.github.io/regCtsem/reference/getFinalParameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getFinalParameters — getFinalParameters","text":"regCtsemObject fitted regularized continuous time model criterion select criterion. Possible AIC, BIC, cvM2LL raw boolean: raw parameters returned (raw = TRUE) log-transformed variances re-transformed (raw = FALSE)","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getFinalParameters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"getFinalParameters — getFinalParameters","text":"NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getFinalParameters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"getFinalParameters — getFinalParameters","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getFlatStdizer.html","id":null,"dir":"Reference","previous_headings":"","what":"getFlatStdizer — getFlatStdizer","title":"getFlatStdizer — getFlatStdizer","text":"returns standardizer standardized drift parameters. Computes SD_predictor/SD_dependent","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getFlatStdizer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getFlatStdizer — getFlatStdizer","text":"","code":"getFlatStdizer(VARIs, driftLabels)"},{"path":"https://jhorzek.github.io/regCtsem/reference/getFlatStdizer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getFlatStdizer — getFlatStdizer","text":"VARIs matrix variances standardization values driftLabels vector drift names","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getFlatStdizer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"getFlatStdizer — getFlatStdizer","text":"NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getMaxLambda.html","id":null,"dir":"Reference","previous_headings":"","what":"getMaxLambda — getMaxLambda","title":"getMaxLambda — getMaxLambda","text":"computes approximation lowest lambda set regularized parameters zero. function adapted Murphy (2012) Machine learning: probabilistic perspective. See p. 434 details.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getMaxLambda.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getMaxLambda — getMaxLambda","text":"","code":"getMaxLambda(   cpptsemObject,   objective,   regIndicators,   targetVector,   adaptiveLassoWeights,   nMultistart )"},{"path":"https://jhorzek.github.io/regCtsem/reference/getMaxLambda.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getMaxLambda — getMaxLambda","text":"cpptsemObject Fitted object class cpptsem objective ML Kalman regIndicators Labels regularized parameters (e.g. drift_eta1_eta2) targetVector vector target values adaptiveLassoWeights weights adaptive lasso. auto, defaults unregularized parameter estimates. nMultistart number multi-start iterations","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getMaxLambda.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"getMaxLambda — getMaxLambda","text":"NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getMaxLambda.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"getMaxLambda — getMaxLambda","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getParameterEstimates.html","id":null,"dir":"Reference","previous_headings":"","what":"getParameterEstimates — getParameterEstimates","title":"getParameterEstimates — getParameterEstimates","text":"computes parameters given raw parameter estimates","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getParameterEstimates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getParameterEstimates — getParameterEstimates","text":"","code":"getParameterEstimates(regCtsemObject, parameterEstimatesRaw)"},{"path":"https://jhorzek.github.io/regCtsem/reference/getParameterEstimates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getParameterEstimates — getParameterEstimates","text":"regCtsemObject regCtsemObject parameterEstimatesRaw raw parameter estimates regularized ctsem","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getParameterEstimates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"getParameterEstimates — getParameterEstimates","text":"NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getRowsAndColsOfNonMissing.html","id":null,"dir":"Reference","previous_headings":"","what":"getRowsAndColsOfNonMissing — getRowsAndColsOfNonMissing","title":"getRowsAndColsOfNonMissing — getRowsAndColsOfNonMissing","text":"Build indicators missingness patterns","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getRowsAndColsOfNonMissing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getRowsAndColsOfNonMissing — getRowsAndColsOfNonMissing","text":"","code":"getRowsAndColsOfNonMissing(uniqueMissingPattern)"},{"path":"https://jhorzek.github.io/regCtsem/reference/getRowsAndColsOfNonMissing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getRowsAndColsOfNonMissing — getRowsAndColsOfNonMissing","text":"uniqueMissingPattern unique missingness patterns","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getT0VAR.html","id":null,"dir":"Reference","previous_headings":"","what":"getT0VAR — getT0VAR","title":"getT0VAR — getT0VAR","text":"extracts T0VAR mxObject","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getT0VAR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getT0VAR — getT0VAR","text":"","code":"getT0VAR(mxObject)"},{"path":"https://jhorzek.github.io/regCtsem/reference/getT0VAR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getT0VAR — getT0VAR","text":"mxObject mxObject","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getT0VAR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"getT0VAR — getT0VAR","text":"NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getVarianceFromVarianceBase.html","id":null,"dir":"Reference","previous_headings":"","what":"getVarianceFromVarianceBase — getVarianceFromVarianceBase","title":"getVarianceFromVarianceBase — getVarianceFromVarianceBase","text":"Computes covariance matrix given covariancebase implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getVarianceFromVarianceBase.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getVarianceFromVarianceBase — getVarianceFromVarianceBase","text":"","code":"getVarianceFromVarianceBase(varianceBaseValues)"},{"path":"https://jhorzek.github.io/regCtsem/reference/getVarianceFromVarianceBase.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getVarianceFromVarianceBase — getVarianceFromVarianceBase","text":"varianceBaseValues matrix base values","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getVarianceFromVarianceBase2.html","id":null,"dir":"Reference","previous_headings":"","what":"getVarianceFromVarianceBase2 — getVarianceFromVarianceBase2","title":"getVarianceFromVarianceBase2 — getVarianceFromVarianceBase2","text":"returns variance varianceBase","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getVarianceFromVarianceBase2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getVarianceFromVarianceBase2 — getVarianceFromVarianceBase2","text":"","code":"getVarianceFromVarianceBase2(varianceBaseValues)"},{"path":"https://jhorzek.github.io/regCtsem/reference/getVarianceFromVarianceBase2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getVarianceFromVarianceBase2 — getVarianceFromVarianceBase2","text":"varianceBaseValues values varianceBase","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getVarianceFromVarianceBase2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"getVarianceFromVarianceBase2 — getVarianceFromVarianceBase2","text":"NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getVarianceFromVarianceBase2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"getVarianceFromVarianceBase2 — getVarianceFromVarianceBase2","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getVariances.html","id":null,"dir":"Reference","previous_headings":"","what":"getVariances — getVariances","title":"getVariances — getVariances","text":"computes variances varianceBase matrices","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getVariances.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getVariances — getVariances","text":"","code":"getVariances(   parameterEstimatesRaw,   matName,   baseMatName,   parameterTable,   nVariables,   variableNames )"},{"path":"https://jhorzek.github.io/regCtsem/reference/getVariances.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getVariances — getVariances","text":"parameterEstimatesRaw raw parameter estimates regularized ctsem matName name new matrix baseMatName name base matrix parameterTable parameterTable nVariables number variables matrix variableNames names variables","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/getVariances.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"getVariances — getVariances","text":"NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/gradCpptsem.html","id":null,"dir":"Reference","previous_headings":"","what":"gradCpptsem — gradCpptsem","title":"gradCpptsem — gradCpptsem","text":"gradCpptsem try compute gradients decreasing precision starting default OpenMx. Allows setting parameters fixed (difference exact_getCppGradients)","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/gradCpptsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gradCpptsem — gradCpptsem","text":"","code":"gradCpptsem(   parameterValues,   cpptsemObject,   objective,   free = labeledFree(parameterValues),   failureReturns = NA )"},{"path":"https://jhorzek.github.io/regCtsem/reference/gradCpptsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gradCpptsem — gradCpptsem","text":"parameterValues vector labeled parameter values cpptsemObject model type cpptsem objective ml Kalman free vector length cpptsemObject$getParameterValues, element specified parameter freely estimated (workaround fixing parameters) failureReturns value returned gradCpptsem fails","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/kalmanFit.html","id":null,"dir":"Reference","previous_headings":"","what":"kalmanFit — kalmanFit","title":"kalmanFit — kalmanFit","text":"Performs prediction updating step Kalman Filter implementation closely follows Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1–36. https://doi.org/10.18637/jss.v077.i05","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/kalmanFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"kalmanFit — kalmanFit","text":"","code":"kalmanFit(   update,   sampleSize,   Tpoints,   nlatent,   nmanifest,   kalmanData,   latentScores,   predictedManifestValues,   discreteTimeParameterNames,   T0MEANSValues,   T0VARValues,   discreteDRIFTUnique,   discreteCINTUnique,   discreteTRAITUnique,   discreteDIFFUSIONUnique,   LAMBDAValues,   MANIFESTMEANSValues,   MANIFESTVARValues )"},{"path":"https://jhorzek.github.io/regCtsem/reference/kalmanFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"kalmanFit — kalmanFit","text":"update boolean sampleSize number persons Tpoints number time points nlatent number latent variables nmanifest number manifest variables kalmanData data Kalman filter latentScores matrix latent scores predictedManifestValues matrix manifest predictions discreteTimeParameterNames names discrete time paramters T0MEANSValues vector initial means T0VARValues matrix initial variances discreteDRIFTUnique list discrete drift values discreteCINTUnique list discrete continuous time intercepts discreteTRAITUnique list discrete traits discreteDIFFUSIONUnique list discrete diffusions LAMBDAValues matrix loadings MANIFESTMEANSValues manifest means MANIFESTVARValues manifest variance","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/labeledFree.html","id":null,"dir":"Reference","previous_headings":"","what":"labeledFree — labeledFree","title":"labeledFree — labeledFree","text":"small helper function. Returns vector TRUE length x labels x","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/labeledFree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"labeledFree — labeledFree","text":"","code":"labeledFree(x)"},{"path":"https://jhorzek.github.io/regCtsem/reference/labeledFree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"labeledFree — labeledFree","text":"x vector labeled values","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/optimizeCpptsem.html","id":null,"dir":"Reference","previous_headings":"","what":"optimizeCpptsem — optimizeCpptsem","title":"optimizeCpptsem — optimizeCpptsem","text":"generic optimization Rslonp","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/optimizeCpptsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"optimizeCpptsem — optimizeCpptsem","text":"","code":"optimizeCpptsem(cpptsemObject, free = \"all\", nMultistart = 0, ...)"},{"path":"https://jhorzek.github.io/regCtsem/reference/optimizeCpptsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"optimizeCpptsem — optimizeCpptsem","text":"cpptsemObject model type cpptsem free named logical vector indicating parameters cpptsemObject$getParameterValues() free nMultistart number multi-start iterations ... additional arguments passed Rsonlp::solnp","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/plot.regCtsem.html","id":null,"dir":"Reference","previous_headings":"","what":"plot.regCtsem — plot.regCtsem","title":"plot.regCtsem — plot.regCtsem","text":"plot.regCtsem","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/plot.regCtsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot.regCtsem — plot.regCtsem","text":"","code":"# S3 method for regCtsem plot(   x,   y = NULL,   ...,   what = \"drift\",   criterion = \"BIC\",   xlab = \"auto\",   ylab = \"auto\" )"},{"path":"https://jhorzek.github.io/regCtsem/reference/plot.regCtsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot.regCtsem — plot.regCtsem","text":"x fitted regCtsem object y NULL ... additional parameters plot matplot (e.g., lty, col, ...) plotted? Possbile : 'drift', 'parameters', 'fit' labels specific parameters criterion vector labels criteria plotted = 'fit' xlab label x axis ylab label y axis","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/plot.regCtsem.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"plot.regCtsem — plot.regCtsem","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/plot.regCtsemCV.html","id":null,"dir":"Reference","previous_headings":"","what":"plot.regCtsemCV — plot.regCtsemCV","title":"plot.regCtsemCV — plot.regCtsemCV","text":"plot.regCtsemCV","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/plot.regCtsemCV.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot.regCtsemCV — plot.regCtsemCV","text":"","code":"# S3 method for regCtsemCV plot(x, y = NULL, ..., xlab = \"auto\", ylab = \"auto\")"},{"path":"https://jhorzek.github.io/regCtsem/reference/plot.regCtsemCV.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot.regCtsemCV — plot.regCtsemCV","text":"x fitted regCtsem object y NULL ... additional parameters plot matplot (e.g., lty, col, ...) xlab label x axis ylab label y axis","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/plot.regCtsemCV.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"plot.regCtsemCV — plot.regCtsemCV","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/plot.regCtsemMultiSubject.html","id":null,"dir":"Reference","previous_headings":"","what":"plot.regCtsemMultiSubject — plot.regCtsemMultiSubject","title":"plot.regCtsemMultiSubject — plot.regCtsemMultiSubject","text":"plot.regCtsemMultiSubject","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/plot.regCtsemMultiSubject.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot.regCtsemMultiSubject — plot.regCtsemMultiSubject","text":"","code":"# S3 method for regCtsemMultiSubject plot(   x,   y = NULL,   ...,   what = \"drift\",   groups = NULL,   criterion = \"BIC\",   xlab = \"auto\",   ylab = \"auto\" )"},{"path":"https://jhorzek.github.io/regCtsem/reference/plot.regCtsemMultiSubject.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot.regCtsemMultiSubject — plot.regCtsemMultiSubject","text":"x fitted regCtsem object y NULL ... additional parameters plot matplot (e.g., lty, col, ...) plotted? Possbile : 'drift', 'parameters', 'fit' groups groups parameters plotted (numeric vector)? criterion vector labels criteria plotted = 'fit' xlab label x axis ylab label y axis","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/plot.regCtsemMultiSubject.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"plot.regCtsemMultiSubject — plot.regCtsemMultiSubject","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareAMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"prepareAMatrix — prepareAMatrix","title":"prepareAMatrix — prepareAMatrix","text":"prepare matrix directed effects RAM model","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareAMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prepareAMatrix — prepareAMatrix","text":"","code":"prepareAMatrix(mxObject, ctMatrices, nlatent, nmanifest, Tpoints, dT)"},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareAMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"prepareAMatrix — prepareAMatrix","text":"mxObject Object type mxObject ctMatrices continuous time matrices nlatent number latent variables nmanifest number manifest variables Tpoints number time points dT time differences","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareDiscreteElementNames.html","id":null,"dir":"Reference","previous_headings":"","what":"prepareDiscreteElementNames — prepareDiscreteElementNames","title":"prepareDiscreteElementNames — prepareDiscreteElementNames","text":"prepare names discrete parameters (e.g. discrete time drift)","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareDiscreteElementNames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prepareDiscreteElementNames — prepareDiscreteElementNames","text":"","code":"prepareDiscreteElementNames(ctMatrices, Tpoints, dT)"},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareDiscreteElementNames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"prepareDiscreteElementNames — prepareDiscreteElementNames","text":"ctMatrices continuous time matrices Tpoints number time points dT time differences","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareDiscreteElements.html","id":null,"dir":"Reference","previous_headings":"","what":"prepareDiscreteElements — prepareDiscreteElements","title":"prepareDiscreteElements — prepareDiscreteElements","text":"prepare matrices discrete time elements","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareDiscreteElements.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prepareDiscreteElements — prepareDiscreteElements","text":"","code":"prepareDiscreteElements(mxObject, ctMatrices, nlatent, nmanifest, Tpoints, dT)"},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareDiscreteElements.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"prepareDiscreteElements — prepareDiscreteElements","text":"mxObject Object type mxObject ctMatrices continuous time matrices nlatent number latent variables nmanifest number manifest variables Tpoints number time points dT time differences","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareFMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"prepareFMatrix — prepareFMatrix","title":"prepareFMatrix — prepareFMatrix","text":"prepare filter matrix RAM model","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareFMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prepareFMatrix — prepareFMatrix","text":"","code":"prepareFMatrix(nlatent, nmanifest, Tpoints)"},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareFMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"prepareFMatrix — prepareFMatrix","text":"nlatent number latent variables nmanifest number manifest variables Tpoints number time points","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareKalmanData.html","id":null,"dir":"Reference","previous_headings":"","what":"prepareKalmanData — prepareKalmanData","title":"prepareKalmanData — prepareKalmanData","text":"prepare data Kalman model","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareKalmanData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prepareKalmanData — prepareKalmanData","text":"","code":"prepareKalmanData(dataset, nlatent, nmanifest, dtIndicators, Tpoints)"},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareKalmanData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"prepareKalmanData — prepareKalmanData","text":"dataset data set nlatent number latent variables nmanifest number manifest variables dtIndicators indicators discrete time parameters Tpoints number time points","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareKalmanMatrices.html","id":null,"dir":"Reference","previous_headings":"","what":"prepareKalmanMatrices — prepareKalmanMatrices","title":"prepareKalmanMatrices — prepareKalmanMatrices","text":"prepare matrices Kalman model","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareKalmanMatrices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prepareKalmanMatrices — prepareKalmanMatrices","text":"","code":"prepareKalmanMatrices(nlatent, nmanifest, Tpoints, sampleSize)"},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareKalmanMatrices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"prepareKalmanMatrices — prepareKalmanMatrices","text":"nlatent number latent variables nmanifest number manifest variables Tpoints number time points sampleSize number persons","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareMMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"prepareMMatrix — prepareMMatrix","title":"prepareMMatrix — prepareMMatrix","text":"prepare matrix means RAM model","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareMMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prepareMMatrix — prepareMMatrix","text":"","code":"prepareMMatrix(   mxObject,   ctMatrices,   nlatent,   nmanifest,   Tpoints,   dT,   stationaryT0MEANS )"},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareMMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"prepareMMatrix — prepareMMatrix","text":"mxObject Object type mxObject ctMatrices continuous time matrices nlatent number latent variables nmanifest number manifest variables Tpoints number time points dT time intervals stationaryT0MEANS boolean: Means stationary?","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareRAMData.html","id":null,"dir":"Reference","previous_headings":"","what":"prepareRAMData — prepareRAMData","title":"prepareRAMData — prepareRAMData","text":"prepare data RAM model","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareRAMData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prepareRAMData — prepareRAMData","text":"","code":"prepareRAMData(dataset, individualMissingPatternID, uniqueMissingPatterns)"},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareRAMData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"prepareRAMData — prepareRAMData","text":"dataset dataset individualMissingPatternID IDs individual missingness pattern uniqueMissingPatterns unique missingness patterns","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareSMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"prepareSMatrix — prepareSMatrix","title":"prepareSMatrix — prepareSMatrix","text":"prepare matrix covariances RAM model","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareSMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"prepareSMatrix — prepareSMatrix","text":"","code":"prepareSMatrix(   mxObject,   ctMatrices,   nlatent,   nmanifest,   Tpoints,   dT,   stationaryT0VAR )"},{"path":"https://jhorzek.github.io/regCtsem/reference/prepareSMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"prepareSMatrix — prepareSMatrix","text":"mxObject Object type mxObject ctMatrices continuous time matrices nlatent number latent variables nmanifest number manifest variables Tpoints number time points dT time intervals stationaryT0VAR boolean: variances stationary?","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/regCtsem.html","id":null,"dir":"Reference","previous_headings":"","what":"regCtsem — regCtsem","title":"regCtsem — regCtsem","text":"Regularized Continuous Time Structural Equation Modeling. regCtsem uses objects ctsemOMX implements lasso, adaptive lasso ridge regularization.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/regCtsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"regCtsem — regCtsem","text":"","code":"regCtsem(   ctsemObject,   dataset,   regIndicators,   targetVector = NULL,   lambdas = \"auto\",   lambdasAutoLength = 50,   lambdasAutoCurve = 10,   penalty = \"lasso\",   adaptiveLassoWeights = NULL,   adaptiveLassoPower = -1,   cvSample = NULL,   autoCV = \"No\",   k = 5,   sparseParameters = NULL,   subjectSpecificParameters = NULL,   standardizeDrift = \"No\",   scaleLambdaWithN = TRUE,   returnFitIndices = TRUE,   BICWithNAndT = FALSE,   optimization = \"exact\",   optimizer = \"GIST\",   control = list(),   verbose = 0,   trainingWheels = TRUE )"},{"path":"https://jhorzek.github.io/regCtsem/reference/regCtsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"regCtsem — regCtsem","text":"ctsemObject Fitted object class ctsemFit dataset Data set wide format compatible ctsemOMX regIndicators Labels regularized parameters (e.g. drift_eta1_eta2). targetVector named vector values towards parameters regularized (Standard regularization towards zero) lambdas vector penalty values (tuning parameter). E.g., seq(0,1,.01). Alternatively, lambdas can set \"auto\". regCtsem compute upper limit lambda test lambdasAutoLength increasing lambda values lambdasAutoLength lambdas == \"auto\", lambdasAutoLength determine number lambdas tested. lambdasAutoCurve often good idea unequally spaced lambda steps (e.g., .01,.02,.05,1,5,20). lambdasAutoCurve close 1 lambda values equally spaced, lambdasAutoCurve large lambda values concentrated close 0. See ?getCurvedLambda informations. penalty Currently supported lasso, ridge adaptiveLasso adaptiveLassoWeights weights adaptive lasso. Defaults 1/(|theta|^adaptiveLassoPower), theta maximum likelihood estimate regularized parameters. adaptiveLassoPower power adaptive lasso weights. weights set 1/(|theta|^adaptiveLassoPower). cvSample cross-validation sample. wide format compatible ctsemOMX autoCV automatic cross-validation used? Possible \"\", \"kFold\" \"Blocked\". kFold splits dataset k groups selecting independent units rows. Blocked within-unit split, person blocks observations deleted. See Bulteel, K., Mestdagh, M., Tuerlinckx, F., & Ceulemans, E. (2018). VAR(1) based models always outpredict AR(1) models typical psychological applications. Psychological Methods, 23(4), 740-756. https://doi.org/10.1037/met0000178 detailed explanation k number cross-validation folds autoCV = \"kFold\" autoCV = \"Blocked\" sparseParameters labeled vector parameter estimates sparse model. regValues = \"auto\" sparse parameters computed automatically. subjectSpecificParameters EXPERIMENTAL! vector parameter labels parameters estimated person-specific. parameter labels also passed regIndicators, person-specific parameters regularized towards group-parameter. 2-step-procedure: step 1 parameters constrained equality individuals estimate group parameters. step 2 parameters estimated person-specific, regularized towards group parameter step 1. standardizeDrift Drift parameters standardized automatically? Set '' standardization, 'T0VAR' standardization using T0VAR 'asymptoticDiffusion' standardization using asymptotic diffusion scaleLambdaWithN Boolean: penalty value scaled sample size? True recommended likelihood also sample size dependent returnFitIndices Boolean: fit indices returned? BICWithNAndT Boolean: TRUE = Use N T formula BIC (-2log L + log(N+T)*k, k number parameters model). FALSE = Use N formula BIC (-2log L + log(N)). Defaults FALSE optimization optimization procedure used. Possible  \"exact\" \"approx\". exact recommended sparsity inducing penalty functions (lasso adaptive lasso) optimizer exact optimization: Either GIST GLMNET. using optimization = \"approx\", Rsolnp optimizers optimx can used. See ?optimx control List control arguments optimizer. See ?controlGIST, ?controlGLMNET ?controlApprox respective parameters verbose 0 (default), 1 convergence plot, 2 parameter convergence plot line search progress. trainingWheels set FALSE bells whistles used keep regCtsem track turned (multiple starting values, initial optimization solnp optimx). focus speed instead accuracy. might work simulated data, recommended real data. optimizer quite likely get stuck local minima.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/regCtsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"regCtsem — regCtsem","text":"returns object class regCtsem. Without cross-validation, object fields setup (arguments passed function), fitAndParameters (used internally store fit raw (.e., untransformed) parameters), fit (fit indices, ect.), parameterEstimatesRaw (raw, .e. untransformed parameters; used internally), parameters (transformed parameters)","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/regCtsem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"regCtsem — regCtsem","text":"REGularized Continuous Time Structural Equation Models (regCtsem) implements least absolute shrinkage selection operator (LASSO; Tibshirani, 1996) adaptive LASSO (Zou, 2006) regularization models fitted ctsemOMX (Driver et al., 2017). See vignette(\"regCtsem\", package = \"regCtsem\") introduction additional examples. References: * Driver, C. C., Oud, J. H. L., & Voelkle, M. C. (2017). Continuous Time Structural Equation Modelling R Package ctsem. Journal Statistical Software, 77(5), 1-36. https://doi.org/10.18637/jss.v077.i05 * Tibshirani, R. (1996). Regression Shrinkage Selection via Lasso. Journal Royal Statistical Society. Series B (Methodological), 58(1), 267-288. * Zou, H. (2006). Adaptive Lasso Oracle Properties. Journal American Statistical Association, 101(476), 1418-1429. https://doi.org/10.1198/016214506000000735 NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/regCtsem.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"regCtsem — regCtsem","text":"Jannik Orzek Jannik Orzek <orzek@mpib-berlin.mpg.de>","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/regCtsem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"regCtsem — regCtsem","text":"","code":"# \\donttest{  set.seed(17046)  library(regCtsem)  #### Example 1 #### ## Regularization with FIML objective function  ## Population model:  # set the drift matrix. Note that drift eta_1_eta2 is set to equal 0 in the population. ct_drift <- matrix(c(-.3,.2,0,-.5), ncol = 2)  generatingModel<-ctsem::ctModel(Tpoints=10,n.latent=2,n.TDpred=0,                                 n.TIpred=0,n.manifest=2,                                 MANIFESTVAR=diag(0,2),                                 LAMBDA=diag(1,2),                                 DRIFT=ct_drift,                                 DIFFUSION=matrix(c(.5,0,0,.5),2),                                 CINT=matrix(c(0,0),nrow=2),                                 T0MEANS=matrix(0,ncol=1,nrow=2),                                 T0VAR=diag(1,2), type = \"omx\")  # simulate a training data set dat <- ctsem::ctGenerate(generatingModel, n.subjects = 100, wide = TRUE)  ## Build the analysis model. Note that drift eta1_eta2 is freely estimated # although it is 0 in the population. myModel <- ctsem::ctModel(Tpoints=10,n.latent=2,n.TDpred=0,                           n.TIpred=0,n.manifest=2,                           LAMBDA=diag(1,2),                           MANIFESTVAR=diag(0,2),                           CINT=matrix(c(0,0),nrow=2),                           DIFFUSION=matrix(c('eta1_eta1',0,0,'eta2_eta2'),2),                           T0MEANS=matrix(0,ncol=1,nrow=2),                           T0VAR=\"auto\", type = \"omx\")  # fit the model using ctsemOMX: fit_myModel <- ctsemOMX::ctFit(dat, myModel)  # select DRIFT values for regularization: # Note: If you are unsure what the parameters are called in # your model, check: showParameters(fit_myModel) showParameters(fit_myModel)  # regularize the cross-effects: regIndicators <- c(\"drift_eta2_eta1\", \"drift_eta1_eta2\")  # Optimize model using GIST with lasso penalty regModel <- regCtsem(ctsemObject = fit_myModel,                                dataset = dat,                                regIndicators = regIndicators,                                lambdas = \"auto\",                                lambdasAutoLength = 20) summary(regModel) plot(regModel) plot(regModel, what = \"fit\", criterion = c(\"AIC\", \"BIC\", \"m2LL\"))  # The best parameter estimates and the final model as mxObject can be extracted with: # getFinalParameters(regCtsemObject = regModel, criterion = \"BIC\") # bestModel <- getFinalModel(regCtsemObject = regModel, criterion = \"BIC\") # WARNING: The returned model is of type cpptsem. You can access it's elements with the # $ operator. For example: bestModel$DRIFTValues  # WARNING: If you load an existing regCtsem object, the underlying C++ model will no longer # exist. You can restore this model with restore(). Example: # save(regModel, file = \"regModel.RData\") # load(\"regModel.RData\") # regModel <- restore(regModel) # regModel$setup$cpptsemObject$DRIFTValues  # Optimize model using GLMNET with lasso penalty regModel <- regCtsem(ctsemObject = fit_myModel,                                dataset = dat,                                regIndicators = regIndicators,                                lambdas = \"auto\",                                lambdasAutoLength = 20,                                optimizer = \"GLMNET\")  summary(regModel, criterion = \"BIC\") plot(regModel, what = \"drift\") plot(regModel, what = \"fit\", criterion = c(\"AIC\", \"BIC\", \"m2LL\")) plot(regModel, what = \"drift_eta1_eta2\")  # The same regularization can be performed with the approximate optimization: regModelApprox <- regCtsem(ctsemObject = fit_myModel,                                      dataset = dat,                                      regIndicators = regIndicators,                                      lambdas = \"auto\",                                      lambdasAutoLength = 20,                                      optimization = \"approx\",                                      control = list(                                        epsilon = .001, # epsilon is used to transform the non-differentiable                                        #lasso penalty to a differentiable one if optimization = approx                                        zeroThresh = .04 # threshold below which parameters will be evaluated as == 0                                      ))  # Comparison of parameter estimates: round(regModel$fitAndParameters - regModelApprox$fitAndParameters,4)  #### Example 2 #### ## Regularization with Kalman objective function  set.seed(175446)  ## define the population model:  # set the drift matrix. Note that drift eta_1_eta2 is set to equal 0 in the population. ct_drift <- matrix(c(-.3,.2,0,-.5), ncol = 2)  generatingModel<-ctsem::ctModel(Tpoints=100,n.latent=2,                                 n.TDpred=0,n.TIpred=0,n.manifest=2,                                 MANIFESTVAR=diag(0,2),                                 LAMBDA=diag(1,2),                                 DRIFT=ct_drift,                                 DIFFUSION=matrix(c(.5,0,0,.5),2),                                 CINT=matrix(c(0,0),nrow=2),                                 T0MEANS=matrix(0,ncol=1,nrow=2),                                 T0VAR=diag(1,2), type = \"omx\")  # simulate a training data and testing data set traindata <- ctsem::ctGenerate(generatingModel,n.subjects = 10, wide = TRUE) testdata <- ctsem::ctGenerate(generatingModel,n.subjects = 10, wide = TRUE)  ## Build the analysis model. Note that drift eta1_eta2 is freely estimated # although it is 0 in the population. myModel <- ctsem::ctModel(Tpoints=100,n.latent=2,n.TDpred=0,                           n.TIpred=0,n.manifest=2,                           LAMBDA=diag(1,2),                           MANIFESTVAR=diag(0,2),                           CINT=matrix(c(0,0),nrow=2),                           DIFFUSION=matrix(c('eta1_eta1',0,0,'eta2_eta2'),2),                           T0MEANS=matrix(0,ncol=1,nrow=2),                           T0VAR=\"auto\", type = \"omx\") fit_myModel <- ctFit(dat = traindata, ctmodelobj = myModel, objective = \"Kalman\")  # select DRIFT values: regIndicators <- c(\"drift_eta2_eta1\", \"drift_eta1_eta2\") # Note: If you are unsure what the parameters are called in # your model, check: fit_myModel$ctmodelobj$DRIFT for the drift or # omxGetParameters(fit_myModel$ctmodelobj) for all parameters  ## Optimization with GIST: regModel <- regCtsem(ctsemObject = fit_myModel,                                dataset = traindata,                                regIndicators = regIndicators,                                lambdas = \"auto\",                                lambdasAutoLength = 20,                                cvSample = testdata # data set for cross-validation )  summary(regModel, criterion = \"cvM2LL\") plot(regModel, what = \"fit\", criterion = \"cvM2LL\")  #### EXPERIMENTAL FEATURES: USE WITH CAUTION! ####  library(regCtsem)  ## Example 4: Kalman Filter with person specific parameter values ## WARNING: THIS WILL TAKE A WHILE TO RUN set.seed(175446)  ## define the population model:  # set the drift matrix. Note that drift eta_1_eta2 is set to equal 0 in the population. ct_drift <- matrix(c(-.3,0,.2,-.2),2,2,TRUE) dataset <- c() indpars <- c()  # We will simulate data for 10 individuals with person-specific parameters # These person-specific parameters will then be regularized towards a # common group parameter for(i in 1:10){   while(TRUE){     DRIFT <- ct_drift + matrix(c(0,stats::rnorm(1,0,.5),0,0),2,2,TRUE)     if(!any(Re(eigen(DRIFT)$values) > 0)){break}   }   indpars <- c(indpars, DRIFT[1,2])   generatingModel<-ctsem::ctModel(Tpoints=50,n.latent=2,n.TDpred=0,n.TIpred=0,n.manifest=2,                                   MANIFESTVAR=diag(0,2),                                   LAMBDA=diag(1,2),                                   DRIFT=DRIFT,                                   DIFFUSION=matrix(c(.5,0,0,.5),2),                                   CINT=matrix(0,nrow = 2, ncol = 1),                                   T0MEANS=matrix(0,ncol=1,nrow=2),                                   T0VAR=diag(1,2), type = \"omx\")   dataset <- rbind(dataset, ctsem::ctGenerate(generatingModel,n.subjects = 1, wide = TRUE))  }  ## Build the analysis model. myModel <- ctsem::ctModel(Tpoints=50,n.latent=2,n.TDpred=0,n.TIpred=0,n.manifest=2,                           LAMBDA=diag(1,2),                           MANIFESTVAR=diag(0,2),                           DIFFUSION=matrix(c('eta1_eta1',0,0,'eta2_eta2'),2),                           T0MEANS=matrix(0,ncol=1,nrow=2),                           T0VAR=\"auto\", type = \"omx\") myModel <- ctFit(myModel, dat = dataset, objective = \"Kalman\",                  useOptimizer = TRUE) regIndicators <- c(\"drift_eta2_eta1\", \"drift_eta1_eta2\") # the following parameters will be estimated person-specific and (as we specified this above) # regularized. The regularization will be towards a group parameter subjectSpecificParameters <- c(\"drift_eta2_eta1\", \"drift_eta1_eta2\") regModel <- regCtsem(ctsemObject = myModel,                      dataset = dataset,                      regIndicators = regIndicators,                      lambdasAutoLength = 5, # 5 will not be enough, but this takes some time to execute                      subjectSpecificParameters = subjectSpecificParameters ) summary(regModel, criterion = \"BIC\") plot(regModel, what = \"drift\") # }"},{"path":"https://jhorzek.github.io/regCtsem/reference/restore.html","id":null,"dir":"Reference","previous_headings":"","what":"restore — restore","title":"restore — restore","text":"restore cpptsem object regCtsem object.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/restore.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"restore — restore","text":"","code":"restore(regCtsemObject)"},{"path":"https://jhorzek.github.io/regCtsem/reference/restore.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"restore — restore","text":"regCtsemObject object type regCtsem","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/restore.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"restore — restore","text":"saving loading regCtsem object, underlying C++ model lost. function resores model","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/ridgeKalmanRegM2LLCpptsem.html","id":null,"dir":"Reference","previous_headings":"","what":"ridgeKalmanRegM2LLCpptsem — ridgeKalmanRegM2LLCpptsem","title":"ridgeKalmanRegM2LLCpptsem — ridgeKalmanRegM2LLCpptsem","text":"approximates regularized likelihood function using cpptsem Kalman","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/ridgeKalmanRegM2LLCpptsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ridgeKalmanRegM2LLCpptsem — ridgeKalmanRegM2LLCpptsem","text":"","code":"ridgeKalmanRegM2LLCpptsem(   parameters,   cpptsemmodel,   adaptiveLassoWeights,   N,   lambda_,   regIndicators,   targetVector,   epsilon,   objective,   failureReturns )"},{"path":"https://jhorzek.github.io/regCtsem/reference/ridgeKalmanRegM2LLCpptsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ridgeKalmanRegM2LLCpptsem — ridgeKalmanRegM2LLCpptsem","text":"parameters parameter values cpptsemmodel model returned cpptsem adaptiveLassoWeights vector weights adaptive lasso N sample size lambda_ tuning parameter lambda regIndicators string vector names regularized parameters targetVector named vector values towards parameters regularized epsilon USED; required optimizer call function objective ML Kalman failureReturns value returned regM2LLCpptsem gradCpptsem fails","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/ridgeKalmanRegM2LLCpptsem.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ridgeKalmanRegM2LLCpptsem — ridgeKalmanRegM2LLCpptsem","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/ridgeRAMRegM2LLCpptsem.html","id":null,"dir":"Reference","previous_headings":"","what":"ridgeRAMRegM2LLCpptsem — ridgeRAMRegM2LLCpptsem","title":"ridgeRAMRegM2LLCpptsem — ridgeRAMRegM2LLCpptsem","text":"approximates regularized likelihood function using cpptsem Full Information Maximum Likelihood","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/ridgeRAMRegM2LLCpptsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ridgeRAMRegM2LLCpptsem — ridgeRAMRegM2LLCpptsem","text":"","code":"ridgeRAMRegM2LLCpptsem(   parameters,   cpptsemmodel,   adaptiveLassoWeights,   N,   lambda_,   regIndicators,   targetVector,   epsilon,   objective,   failureReturns )"},{"path":"https://jhorzek.github.io/regCtsem/reference/ridgeRAMRegM2LLCpptsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ridgeRAMRegM2LLCpptsem — ridgeRAMRegM2LLCpptsem","text":"parameters parameter values cpptsemmodel model returned cpptsem adaptiveLassoWeights vector weights adaptive lasso N sample size lambda_ tuning parameter lambda regIndicators string vector names regularized parameters targetVector named vector values towards parameters regularized epsilon USED; required optimizer call function objective ML Kalman failureReturns value returned regM2LLCpptsem gradCpptsem fails","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/ridgeRAMRegM2LLCpptsem.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ridgeRAMRegM2LLCpptsem — ridgeRAMRegM2LLCpptsem","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/separateFitAndParameters.html","id":null,"dir":"Reference","previous_headings":"","what":"separateFitAndParameters — separateFitAndParameters","title":"separateFitAndParameters — separateFitAndParameters","text":"separates fit results parameter estimates","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/separateFitAndParameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"separateFitAndParameters — separateFitAndParameters","text":"","code":"separateFitAndParameters(regCtsemObject)"},{"path":"https://jhorzek.github.io/regCtsem/reference/separateFitAndParameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"separateFitAndParameters — separateFitAndParameters","text":"regCtsemObject Object exact_regCtsem approx_regCtsem","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/separateFitAndParameters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"separateFitAndParameters — separateFitAndParameters","text":"NOTE: Function located file regCtsem.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/separateFitAndParameters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"separateFitAndParameters — separateFitAndParameters","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/showParameters.html","id":null,"dir":"Reference","previous_headings":"","what":"showParameters — showParameters","title":"showParameters — showParameters","text":"shows parameters model fitted ctFit. Importantly, untransformed parameters returned. instance, variance-covariance matrices implemented log-Cholesky form (see Pinheiro, J. C., & Bates, D. M. (1996). Unconstrained parametrizations variance-covariance matrices. Statistics Computing, 6(3), 289–296. https://doi.org/10.1007/BF00140873).","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/showParameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"showParameters — showParameters","text":"","code":"showParameters(ctsemObject)"},{"path":"https://jhorzek.github.io/regCtsem/reference/showParameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"showParameters — showParameters","text":"ctsemObject Fitted object class ctsemFit","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/showParameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"showParameters — showParameters","text":"","code":"library(regCtsem)  # The following example is taken from ?ctFit: data(AnomAuth) AnomAuthmodel <- ctModel(LAMBDA = matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2),                          Tpoints = 5, n.latent = 2, n.manifest = 2, MANIFESTVAR=diag(0, 2), TRAITVAR = NULL) AnomAuthfit <- ctFit(AnomAuth, AnomAuthmodel)  showParameters(AnomAuthfit)"},{"path":"https://jhorzek.github.io/regCtsem/reference/startFromSparse.html","id":null,"dir":"Reference","previous_headings":"","what":"startFromSparse — startFromSparse","title":"startFromSparse — startFromSparse","text":"alpha status function. Start regularized model setting parameters already target values","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/startFromSparse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"startFromSparse — startFromSparse","text":"","code":"startFromSparse(   ctsemObject,   dataset,   regIndicators,   targetVector = NULL,   lambdasAutoLength = 50,   lambdasAutoCurve = 10,   penalty = \"lasso\",   adaptiveLassoWeights = NULL,   adaptiveLassoPower = -1,   cvSample = NULL,   autoCV = \"No\",   k = 5,   subjectSpecificParameters = NULL,   standardizeDrift = \"No\",   scaleLambdaWithN = TRUE,   returnFitIndices = TRUE,   BICWithNAndT = FALSE,   optimization = \"exact\",   optimizer = \"GIST\",   control = list(),   verbose = 0,   trainingWheels = TRUE,   nMultistart = 3,   fitFull = TRUE,   optimizeRegCtsem = TRUE )"},{"path":"https://jhorzek.github.io/regCtsem/reference/startFromSparse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"startFromSparse — startFromSparse","text":"ctsemObject Fitted object class ctsemFit dataset Data set wide format compatible ctsemOMX regIndicators Labels regularized parameters (e.g. drift_eta1_eta2). targetVector named vector values towards parameters regularized (Standard regularization towards zero) lambdasAutoLength lambdasAutoLength determine number lambdas tested. lambdasAutoCurve often good idea unequally spaced lambda steps (e.g., .01,.02,.05,1,5,20). lambdasAutoCurve close 1 lambda values equally spaced, lambdasAutoCurve large lambda values concentrated close 0. See ?getCurvedLambda informations. penalty Currently supported lasso, ridge adaptiveLasso adaptiveLassoWeights weights adaptive lasso. Defaults 1/(|theta|^adaptiveLassoPower), theta maximum likelihood estimate regularized parameters. adaptiveLassoPower power adaptive lasso weights. weights set 1/(|theta|^adaptiveLassoPower). cvSample cross-validation sample. wide format compatible ctsemOMX autoCV automatic cross-validation used? Possible \"\", \"kFold\" \"Blocked\". kFold splits dataset k groups selecting independent units rows. Blocked within-unit split, person blocks observations deleted. See Bulteel, K., Mestdagh, M., Tuerlinckx, F., & Ceulemans, E. (2018). VAR(1) based models always outpredict AR(1) models typical psychological applications. Psychological Methods, 23(4), 740–756. https://doi.org/10.1037/met0000178 detailed explanation k number cross-validation folds autoCV = \"kFold\" autoCV = \"Blocked\" subjectSpecificParameters EXPERIMENTAL! vector parameter labels parameters estimated person-specific. parameter labels also passed regIndicators, person-specific parameters regularized towards group-parameter. 2-step-procedure: step 1 parameters constrained equality individuals estimate group parameters. step 2 parameters estimated person-specific, regularized towards group parameter step 1. standardizeDrift Drift parameters standardized automatically? Set '' standardization, 'T0VAR' standardization using T0VAR 'asymptoticDiffusion' standardization using asymptotic diffusion scaleLambdaWithN Boolean: penalty value scaled sample size? True recommended likelihood also sample size dependent returnFitIndices Boolean: fit indices returned? BICWithNAndT Boolean: TRUE = Use N T formula BIC (-2log L + log(N+T)*k, k number parameters model). FALSE = Use N formula BIC (-2log L + log(N)). Defaults FALSE optimization optimization procedure used. Possible  \"exact\" \"approx\". exact recommended sparsity inducing penalty functions (lasso adaptive lasso) optimizer exact optimization: Either GIST GLMNET. using optimization = \"approx\", Rsolnp optimizers optimx can used. See ?optimx control List control arguments optimizer. See ?controlGIST, ?controlGLMNET ?controlApprox respective parameters verbose 0 (default), 1 convergence plot, 2 parameter convergence plot line search progress. trainingWheels set FALSE bells whistles used keep regCtsem track turned (multiple starting values, initial optimization solnp optimx). focus speed instead accuracy. might work simulated data, recommended real data. optimizer quite likely get stuck local minima. nMultistart number additional tries optimizing models fitFull boolean: used adaptiveLASSO weights. full model (model without regularization) fitted (TRUE) approximated (FALSE). Approximation might work sometimes, always. optimizeRegCtsem set false, function return lambda_max, vector sparse parameter values vector full, unregularized model parameters","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/startFromSparse.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"startFromSparse — startFromSparse","text":"NOTE: Function located file utils.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/startFromSparse.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"startFromSparse — startFromSparse","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/summary.regCtsem.html","id":null,"dir":"Reference","previous_headings":"","what":"summary.regCtsem — summary.regCtsem","title":"summary.regCtsem — summary.regCtsem","text":"summary.regCtsem","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/summary.regCtsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summary.regCtsem — summary.regCtsem","text":"","code":"# S3 method for regCtsem summary(object, ..., criterion = NULL)"},{"path":"https://jhorzek.github.io/regCtsem/reference/summary.regCtsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summary.regCtsem — summary.regCtsem","text":"object Object type regCtsem ... NULL criterion select criterion. Possible AIC, BIC, cvM2LL","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/summary.regCtsem.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"summary.regCtsem — summary.regCtsem","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/summary.regCtsemCV.html","id":null,"dir":"Reference","previous_headings":"","what":"summary.regCtsemCV — summary.regCtsemCV","title":"summary.regCtsemCV — summary.regCtsemCV","text":"summary.regCtsemCV","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/summary.regCtsemCV.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summary.regCtsemCV — summary.regCtsemCV","text":"","code":"# S3 method for regCtsemCV summary(object, ...)"},{"path":"https://jhorzek.github.io/regCtsem/reference/summary.regCtsemCV.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summary.regCtsemCV — summary.regCtsemCV","text":"object Object type regCtsemCV ... NULL","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/summary.regCtsemCV.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"summary.regCtsemCV — summary.regCtsemCV","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/summary.regCtsemMultiSubject.html","id":null,"dir":"Reference","previous_headings":"","what":"summary.regCtsemMultiSubject — summary.regCtsemMultiSubject","title":"summary.regCtsemMultiSubject — summary.regCtsemMultiSubject","text":"summary.regCtsemMultiSubject","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/summary.regCtsemMultiSubject.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summary.regCtsemMultiSubject — summary.regCtsemMultiSubject","text":"","code":"# S3 method for regCtsemMultiSubject summary(object, ..., criterion = NULL)"},{"path":"https://jhorzek.github.io/regCtsem/reference/summary.regCtsemMultiSubject.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summary.regCtsemMultiSubject — summary.regCtsemMultiSubject","text":"object Object type regCtsemMultiSubject ... NULL criterion select criterion. Possible AIC BIC","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/summary.regCtsemMultiSubject.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"summary.regCtsemMultiSubject — summary.regCtsemMultiSubject","text":"Jannik Orzek","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/tryApproxFirst.html","id":null,"dir":"Reference","previous_headings":"","what":"tryApproxFirst — tryApproxFirst","title":"tryApproxFirst — tryApproxFirst","text":"Approximates solution lasso regularized fitting function using established optimizer","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/tryApproxFirst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"tryApproxFirst — tryApproxFirst","text":"","code":"tryApproxFirst(   startingValues,   returnAs,   approxFirst,   numStart,   controlApproxOptimizer,   lambda,   cpptsemObject,   regIndicators,   targetVector,   adaptiveLassoWeights,   objective,   sparseParameters )"},{"path":"https://jhorzek.github.io/regCtsem/reference/tryApproxFirst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"tryApproxFirst — tryApproxFirst","text":"startingValues start values optimization returnAs \"vector\" \"matrix\" approxFirst boolean: solution approximated numStart number starting values controlApproxOptimizer settings passed optimx Rsolnp lambda tuning parameter value cpptsemObject object type cpptsem regIndicators Labels regularized parameters (e.g. drift_eta1_eta2) targetVector named vector values towards parameters regularized adaptiveLassoWeights weights adaptive lasso. objective objective used? Possible \"ML\" (Maximum Likelihood) \"Kalman\" (Kalman Filter) sparseParameters labeled vector parameter estimates sparse model.","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/tryApproxFirst.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"tryApproxFirst — tryApproxFirst","text":"NOTE: Function located file exact_optimization.R","code":""},{"path":"https://jhorzek.github.io/regCtsem/reference/tryApproxFirst.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"tryApproxFirst — tryApproxFirst","text":"Jannik Orzek","code":""}]
