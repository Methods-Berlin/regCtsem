% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/regCtsem.R, R/zzz.R
\docType{package}
\name{regCtsem}
\alias{regCtsem}
\title{regCtsem}
\usage{
regCtsem(
  ctsemObject = NULL,
  mxObject = NULL,
  dataset = NULL,
  regOn = "DRIFT",
  regIndicators,
  lambdas = "auto",
  lambdasAutoLength = 50,
  penalty = "lasso",
  adaptiveLassoWeights = NULL,
  elastic_alpha = NULL,
  elastic_gamma = NULL,
  cvSample = NULL,
  autoCV = FALSE,
  k = 5,
  objective = "ML",
  KalmanStartValues = NULL,
  optimizeKalman = TRUE,
  sparseParameters = NULL,
  standardizeDrift = FALSE,
  scaleLambdaWithN = TRUE,
  returnFitIndices = TRUE,
  optimization = "exact",
  optimizer = "GIST",
  control = list(),
  extraTries = 3,
  cores = 1,
  verbose = 0,
  silent = FALSE,
  progressBar = TRUE,
  parallelProgressBar = NULL,
  calledInternally = FALSE
)
}
\arguments{
\item{ctsemObject}{if objective = "ML": Fitted object of class ctsem. If you want to use objective = "Kalman", pass an object of type ctsemInit from ctModel}

\item{mxObject}{Fitted object of class MxObject extracted from ctsemObject. Provide either ctsemObject or mxObject}

\item{dataset}{only required if objective = "Kalman" and ctsemObject is of type ctsemInit. Please provide a data set in wide format compatible to ctsemOMX}

\item{regOn}{string specifying which matrix should be regularized. Currently only supports DRIFT}

\item{regIndicators}{matrix with ones and zeros specifying which parameters in regOn should be regularized. Must be of same size as the regularized matrix. 1 = regularized, 0 = not regularized. Alternatively, labels for the regularized parameters can be used (e.g. drift_eta1_eta2)}

\item{lambdas}{vector of penalty values (tuning parameter). E.g., seq(0,1,.01). Alternatively, lambdas can be set to "auto"; however, this is still experimental.}

\item{lambdasAutoLength}{if lambdas == "auto", lambdasAutoLength will determine the number of lambdas tested.}

\item{penalty}{type. Currently supported are lasso and ridge for optimization = approx and lasso and adaptiveLasso for optimization = exact}

\item{adaptiveLassoWeights}{weights for the adaptive lasso. If auto, defaults to the unregularized parameter estimates.}

\item{elastic_alpha}{placehoder for elastic net. NOT YET IMPLEMENTED}

\item{elastic_gamma}{placehoder for elastic net. NOT YET IMPLEMENTED}

\item{cvSample}{cross-validation sample. Has to be of type mxData}

\item{autoCV}{Boolean: Should automatic cross-validation be used?}

\item{k}{number of cross-validation folds if autoCV = TRUE (k-fold cross-validation)}

\item{objective}{which objective should be used? Possible are "ML" (Maximum Likelihood) or "Kalman" (Kalman Filter)}

\item{KalmanStartValues}{Optional starting values for the parameters when using Kalman filter}

\item{optimizeKalman}{Boolen: Should the Kalman model be optimized in OpenMx first? If you want the Kalman model to start optimizing in regCtsem from the provided KalmanStartValues and not use OpenMx to optimize the initial Kalman model, set to FALSE}

\item{sparseParameters}{labeled vector with parameter estimates of the most sparse model. Required for approxFirst = 3}

\item{standardizeDrift}{Boolean: Should Drift parameters be standardized automatically using T0VAR?}

\item{scaleLambdaWithN}{Boolean: Should the penalty value be scaled with the sample size? True is recommended, as the likelihood is also sample size dependent}

\item{returnFitIndices}{Boolean: should fit indices be returned?}

\item{optimization}{which optimization procedure should be used. Possible are  "exact" or "approx".}

\item{optimizer}{for exact optimization: Either GIST or GLMNET}

\item{control}{List with control arguments for the optimizer. See ?controlGIST, ?controlGLMNET and ?controlApprox for the respective parameters}

\item{extraTries}{number of extra tries in mxTryHard}

\item{cores}{how many computer cores should be used?}

\item{verbose}{0 (default), 1 for convergence plot, 2 for parameter convergence plot and line search progress}

\item{silent}{silent execution}

\item{progressBar}{Boolean: Should a progress bar be displayed}

\item{parallelProgressBar}{list: used internally to display progress when executing in parallel. Do not pass values to parallelProgressBar}

\item{calledInternally}{Boolean: used internally for skipping checks}
}
\description{
main function: performs regularized ctsem

This package is based on ctsem and can regularize Drift parameters in continuous time structural equation models
}
\details{
NOTE: Function located in file regCtsem.R
}
\examples{
set.seed(17046)

library(regCtsem)

#### Example 1 ####
## Regularization with FIML objective function

## Population model:

# set the drift matrix. Note that drift eta_1_eta2 is set to equal 0 in the population.
ct_drift <- matrix(c(-.3,.2,0,-.5), ncol = 2)

generatingModel<-ctsem::ctModel(Tpoints=10,n.latent=2,n.TDpred=0,
                                n.TIpred=0,n.manifest=2,
                                MANIFESTVAR=diag(0,2),
                                LAMBDA=diag(1,2),
                                DRIFT=ct_drift,
                                DIFFUSION=matrix(c(.5,0,0,.5),2),
                                CINT=matrix(c(0,0),nrow=2),
                                T0MEANS=matrix(0,ncol=1,nrow=2),
                                T0VAR=diag(1,2), type = "omx")

# simulate a training data set
dat <- ctsem::ctGenerate(generatingModel, n.subjects = 100, wide = TRUE)

## Build the analysis model. Note that drift eta1_eta2 is freely estimated
# although it is 0 in the population.
myModel <- ctsem::ctModel(Tpoints=10,n.latent=2,n.TDpred=0,
                          n.TIpred=0,n.manifest=2,
                          LAMBDA=diag(1,2),
                          MANIFESTVAR=diag(0,2),
                          CINT=matrix(c(0,0),nrow=2),
                          DIFFUSION=matrix(c('eta1_eta1',0,0,'eta2_eta2'),2),
                          T0MEANS=matrix(0,ncol=1,nrow=2),
                          T0VAR="auto", type = "omx")

# fit the model using ctsemOMX:
fit_myModel <- ctsemOMX::ctFit(dat, myModel)

# select DRIFT values for regularization:
regOn = "DRIFT"
regIndicators = matrix(c(0,1,
                         1,0),
                       byrow = T, nrow = 2)

# Optimize model using GIST with lasso penalty
regModel <- regCtsem::regCtsem(ctsemObject = fit_myModel,
                               regOn = regOn,
                               regIndicators = regIndicators,
                               lambdas = "auto",
                               lambdasAutoLength = 15)

summary(regModel, criterion = "BIC")
plot(regModel, what = "drift")
plot(regModel, what = "fit", criterion = c("AIC", "BIC", "m2LL"))

# Using shinyfy can also give some insights into the model:
# shinyfy(regCtsemObject = regModel)

# The best parameter estimates and the final model as mxObject can be extracted with:
# getFinalParameters(regCtsemObject = regModel, criterion = "BIC")
# bestModel <- getFinalModel(regCtsemObject = regModel, criterion = "BIC")

# Optimize model using GLMNET with lasso penalty
regModel <- regCtsem::regCtsem(ctsemObject = fit_myModel,
                               regOn = regOn,
                               regIndicators = regIndicators,
                               lambdas = "auto",
                               lambdasAutoLength = 15,
                               optimizer = "GLMNET")

summary(regModel, criterion = "BIC")
plot(regModel, what = "drift")
plot(regModel, what = "fit", criterion = c("AIC", "BIC", "m2LL"))

# The same regularization can be performed with the approximate optimization:
# Note that we are using extraTries to get better parameter estimates
regModelApprox <- regCtsem::regCtsem(ctsemObject = fit_myModel,
                                     regOn = regOn,
                                     regIndicators = regIndicators,
                                     lambdas = "auto",
                                     lambdasAutoLength = 15,
                                     optimization = "approx",
                                     control = list(
                                       epsilon = .001, # epsilon is used to transform the non-differentiable
                                       #lasso penalty to a differentiable one if optimization = approx
                                       zeroThresh = .04 # threshold below which parameters will be evaluated as == 0
                                     ),
                                     extraTries = 5)

# Comparison of parameter estimates:
round(regModel$fitAndParameters - regModelApprox$fitAndParameters,4)

#### Example 2 ####
## Regularization with Kalman objective function

set.seed(175446)

## define the population model:

# set the drift matrix. Note that drift eta_1_eta2 is set to equal 0 in the population.
ct_drift <- matrix(c(-.3,.2,0,-.5), ncol = 2)

generatingModel<-ctsem::ctModel(Tpoints=100,n.latent=2,
                                n.TDpred=0,n.TIpred=0,n.manifest=2,
                                MANIFESTVAR=diag(0,2),
                                LAMBDA=diag(1,2),
                                DRIFT=ct_drift,
                                DIFFUSION=matrix(c(.5,0,0,.5),2),
                                CINT=matrix(c(0,0),nrow=2),
                                T0MEANS=matrix(0,ncol=1,nrow=2),
                                T0VAR=diag(1,2), type = "omx")

# simulate a training data and testing data set
traindata <- ctsem::ctGenerate(generatingModel,n.subjects = 10, wide = TRUE)
testdata <- ctsem::ctGenerate(generatingModel,n.subjects = 10, wide = TRUE)

## Build the analysis model. Note that drift eta1_eta2 is freely estimated
# although it is 0 in the population.
myModel <- ctsem::ctModel(Tpoints=100,n.latent=2,n.TDpred=0,
                          n.TIpred=0,n.manifest=2,
                          LAMBDA=diag(1,2),
                          MANIFESTVAR=diag(0,2),
                          CINT=matrix(c(0,0),nrow=2),
                          DIFFUSION=matrix(c('eta1_eta1',0,0,'eta2_eta2'),2),
                          T0MEANS=matrix(0,ncol=1,nrow=2),
                          T0VAR="auto", type = "omx")

# select DRIFT values:
regOn = "DRIFT"
regIndicators = matrix(c(0,1,1,0), byrow = T, ncol = 2)

## Optimization with GIST:
regModel <- regCtsem::regCtsem(# important: We now have to pass the ctModel object, not the fitted model!
  ctsemObject = myModel,
  # Furthermore, the data has to be passed to regCtsem
  dataset = traindata,
  regOn = regOn,
  regIndicators = regIndicators,
  lambdas = "auto",
  lambdasAutoLength = 15,
  cvSample = testdata,
  objective = "Kalman",
  cores = 2
)

summary(regModel, criterion = "cvM2LL")
plot(regModel, what = "fit", criterion = "cvM2LL")

}
\author{
Jannik Orzek

Jannik Orzek <orzek@mpib-berlin.mpg.de>
}
