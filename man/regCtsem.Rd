% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/regCtsem.R, R/zzz.R
\docType{package}
\name{regCtsem}
\alias{regCtsem}
\title{regCtsem}
\usage{
regCtsem(
  ctsemObject,
  dataset,
  regIndicators,
  targetVector = NULL,
  lambdas = "auto",
  lambdasAutoLength = 50,
  penalty = "lasso",
  adaptiveLassoWeights = NULL,
  cvSample = NULL,
  autoCV = FALSE,
  k = 5,
  sparseParameters = NULL,
  standardizeDrift = FALSE,
  scaleLambdaWithN = TRUE,
  returnFitIndices = TRUE,
  optimization = "exact",
  optimizer = "GIST",
  control = list(),
  verbose = 0
)
}
\arguments{
\item{ctsemObject}{Fitted object of class ctsemFit}

\item{dataset}{Please provide a data set in wide format compatible to ctsemOMX}

\item{regIndicators}{Labels of the regularized parameters (e.g. drift_eta1_eta2).}

\item{targetVector}{named vector with values towards which the parameters are regularized (Standard is regularization towards zero)}

\item{lambdas}{vector of penalty values (tuning parameter). E.g., seq(0,1,.01). Alternatively, lambdas can be set to "auto". regCtsem will then compute an upper limit for lambda and test lambdasAutoLength increasing lambda values}

\item{lambdasAutoLength}{if lambdas == "auto", lambdasAutoLength will determine the number of lambdas tested.}

\item{penalty}{Currently supported are lasso, ridge and adaptiveLasso}

\item{adaptiveLassoWeights}{weights for the adaptive lasso. If auto, defaults to the inverse of unregularized parameter estimates.}

\item{cvSample}{cross-validation sample. Has to be in wide format and compatible with ctsemOMX}

\item{autoCV}{Boolean: Should automatic cross-validation be used?}

\item{k}{number of cross-validation folds if autoCV = TRUE (k-fold cross-validation)}

\item{sparseParameters}{labeled vector with parameter estimates of the most sparse model. Required for approxFirst = 3. If regValues = "auto" the sparse parameters will be computed automatically.}

\item{standardizeDrift}{Boolean: Should Drift parameters be standardized automatically using the T0VAR?}

\item{scaleLambdaWithN}{Boolean: Should the penalty value be scaled with the sample size? True is recommended as the likelihood is also sample size dependent}

\item{returnFitIndices}{Boolean: should fit indices be returned?}

\item{optimization}{which optimization procedure should be used. Possible are  "exact" or "approx". exact is recommended}

\item{optimizer}{for exact optimization: Either GIST or GLMNET}

\item{control}{List with control arguments for the optimizer. See ?controlGIST, ?controlGLMNET and ?controlApprox for the respective parameters}

\item{verbose}{0 (default), 1 for convergence plot, 2 for parameter convergence plot and line search progress.}

\item{optimizerApprox}{for approximate optimization. Chose from optimx optimizers}
}
\value{
returns an object of class regCtsem. Without cross-validation, this object will have the fields setup (all arguments passed to the function), fitAndParameters (used internally to store the fit and the raw (i.e., untransformed) parameters), fit (fit indices, ect.), parameterEstimatesRaw (raw, i.e. untransformed parameters; used internally), and parameters (transformed parameters)#'
}
\description{
main function: performs regularized ctsem

This package is based on ctsem and can regularize Drift parameters in continuous time structural equation models
}
\details{
NOTE: Function located in file regCtsem.R
}
\examples{
set.seed(17046)

library(regCtsem)

#### Example 1 ####
## Regularization with FIML objective function

## Population model:

# set the drift matrix. Note that drift eta_1_eta2 is set to equal 0 in the population.
ct_drift <- matrix(c(-.3,.2,0,-.5), ncol = 2)

generatingModel<-ctsem::ctModel(Tpoints=10,n.latent=2,n.TDpred=0,
                                n.TIpred=0,n.manifest=2,
                                MANIFESTVAR=diag(0,2),
                                LAMBDA=diag(1,2),
                                DRIFT=ct_drift,
                                DIFFUSION=matrix(c(.5,0,0,.5),2),
                                CINT=matrix(c(0,0),nrow=2),
                                T0MEANS=matrix(0,ncol=1,nrow=2),
                                T0VAR=diag(1,2), type = "omx")

# simulate a training data set
dat <- ctsem::ctGenerate(generatingModel, n.subjects = 100, wide = TRUE)

## Build the analysis model. Note that drift eta1_eta2 is freely estimated
# although it is 0 in the population.
myModel <- ctsem::ctModel(Tpoints=10,n.latent=2,n.TDpred=0,
                          n.TIpred=0,n.manifest=2,
                          LAMBDA=diag(1,2),
                          MANIFESTVAR=diag(0,2),
                          CINT=matrix(c(0,0),nrow=2),
                          DIFFUSION=matrix(c('eta1_eta1',0,0,'eta2_eta2'),2),
                          T0MEANS=matrix(0,ncol=1,nrow=2),
                          T0VAR="auto", type = "omx")

# fit the model using ctsemOMX:
fit_myModel <- ctsemOMX::ctFit(dat, myModel)

# select DRIFT values for regularization:
regIndicators = matrix(c(0,1,
                         1,0),
                       byrow = T, nrow = 2)

# Optimize model using GIST with lasso penalty
regModel <- regCtsem::regCtsem(ctsemObject = fit_myModel,
                               regIndicators = regIndicators,
                               lambdas = "auto",
                               lambdasAutoLength = 20)

summary(regModel, criterion = "BIC")
plot(regModel, what = "drift")
plot(regModel, what = "fit", criterion = c("AIC", "BIC", "m2LL"))

# Using shinyfy can also give some insights into the model:
# shinyfy(regCtsemObject = regModel)

# The best parameter estimates and the final model as mxObject can be extracted with:
# getFinalParameters(regCtsemObject = regModel, criterion = "BIC")
# bestModel <- getFinalModel(regCtsemObject = regModel, criterion = "BIC")

# Optimize model using GLMNET with lasso penalty
regModel <- regCtsem::regCtsem(ctsemObject = fit_myModel,
                               regIndicators = regIndicators,
                               lambdas = "auto",
                               lambdasAutoLength = 20,
                               optimizer = "GLMNET")

summary(regModel, criterion = "BIC")
plot(regModel, what = "drift")
plot(regModel, what = "fit", criterion = c("AIC", "BIC", "m2LL"))

# The same regularization can be performed with the approximate optimization:
# Note that we are using extraTries to get better parameter estimates
regModelApprox <- regCtsem::regCtsem(ctsemObject = fit_myModel,
                                     regIndicators = regIndicators,
                                     lambdas = "auto",
                                     lambdasAutoLength = 20,
                                     optimization = "approx",
                                     control = list(
                                       epsilon = .001, # epsilon is used to transform the non-differentiable
                                       #lasso penalty to a differentiable one if optimization = approx
                                       zeroThresh = .04 # threshold below which parameters will be evaluated as == 0
                                     ),
                                     extraTries = 5)

# Comparison of parameter estimates:
round(regModel$fitAndParameters - regModelApprox$fitAndParameters,4)

#### Example 2 ####
## Regularization with Kalman objective function

set.seed(175446)

## define the population model:

# set the drift matrix. Note that drift eta_1_eta2 is set to equal 0 in the population.
ct_drift <- matrix(c(-.3,.2,0,-.5), ncol = 2)

generatingModel<-ctsem::ctModel(Tpoints=100,n.latent=2,
                                n.TDpred=0,n.TIpred=0,n.manifest=2,
                                MANIFESTVAR=diag(0,2),
                                LAMBDA=diag(1,2),
                                DRIFT=ct_drift,
                                DIFFUSION=matrix(c(.5,0,0,.5),2),
                                CINT=matrix(c(0,0),nrow=2),
                                T0MEANS=matrix(0,ncol=1,nrow=2),
                                T0VAR=diag(1,2), type = "omx")

# simulate a training data and testing data set
traindata <- ctsem::ctGenerate(generatingModel,n.subjects = 10, wide = TRUE)
testdata <- ctsem::ctGenerate(generatingModel,n.subjects = 10, wide = TRUE)

## Build the analysis model. Note that drift eta1_eta2 is freely estimated
# although it is 0 in the population.
myModel <- ctsem::ctModel(Tpoints=100,n.latent=2,n.TDpred=0,
                          n.TIpred=0,n.manifest=2,
                          LAMBDA=diag(1,2),
                          MANIFESTVAR=diag(0,2),
                          CINT=matrix(c(0,0),nrow=2),
                          DIFFUSION=matrix(c('eta1_eta1',0,0,'eta2_eta2'),2),
                          T0MEANS=matrix(0,ncol=1,nrow=2),
                          T0VAR="auto", type = "omx")

# select DRIFT values:
regIndicators = matrix(c(0,1,1,0), byrow = T, ncol = 2)

## Optimization with GIST:
regModel <- regCtsem::regCtsem(# important: We now have to pass the ctModel object, not the fitted model!
  ctsemObject = myModel,
  # Furthermore, the data has to be passed to regCtsem
  dataset = traindata,
  regIndicators = regIndicators,
  lambdas = "auto",
  lambdasAutoLength = 20,
  cvSample = testdata,
  objective = "Kalman",
  cores = 2
)

summary(regModel, criterion = "cvM2LL")
plot(regModel, what = "fit", criterion = "cvM2LL")

}
\author{
Jannik Orzek

Jannik Orzek <orzek@mpib-berlin.mpg.de>
}
